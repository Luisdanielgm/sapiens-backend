Plan de Implementaci√≥n: Eliminaci√≥n de Roles Obsoletos y Modelo de Workspaces
Backend ‚Äì Refactorizaci√≥n de Roles y Modelo de Datos
Eliminar Roles SYSTEM y SUPER_ADMIN:
Constantes y Seeds: Remueva las entradas "SUPER_ADMIN" y "SYSTEM" del diccionario de roles en el c√≥digo backend
GitHub
, as√≠ como cualquier referencia a estos roles en datos precargados (seeds/fixtures) o configuraciones. Por ejemplo, en las rutas de correcci√≥n el endpoint de procesamiento en cola actualmente exige el rol SYSTEM
GitHub
; aj√∫stelo para que solo requiera un rol administrativo v√°lido (p. ej. ADMIN) o implemente otra forma segura de invocarlo (como un token de servicio protegido por secret).
Validaciones y Permisos: Recorrer todo el c√≥digo buscando SUPER_ADMIN/SYSTEM (p. ej. decoradores @role_required o l√≥gica condicional) y eliminar esas condiciones o sustituirlas por roles existentes. Dado que estos roles no se usan activamente en la aplicaci√≥n, su eliminaci√≥n no deber√≠a romper flujos l√≥gicos. Aseg√∫rese de actualizar cualquier l√≥gica de ‚Äúusuario de sistema‚Äù a usar alternativas (un rol ADMIN o un proceso cron externo seg√∫n corresponda).
Unificar Roles Base (eliminar INDIVIDUAL_ globales):*
Constantes de Rol: Elimine INDIVIDUAL_TEACHER e INDIVIDUAL_STUDENT de la definici√≥n global de roles
GitHub
. Estos ya no ser√°n roles principales en la colecci√≥n users, sino que pasar√°n a representarse como tipos de workspace.
Referencias en C√≥digo: Actualice cualquier chequeo if user.role == 'individual_teacher' o similar. Por ejemplo, en el registro de usuarios actualmente se detectan esos roles para l√≥gica especial
GitHub
; dicha l√≥gica se trasladar√° (ver siguiente punto). Tras el refactor, los usuarios solo tendr√°n roles base como "STUDENT", "TEACHER", "INSTITUTE_ADMIN" o "ADMIN". Esto simplifica los permisos generales.
Datos Existentes ‚Äì Usuarios: Dise√±e una migraci√≥n para convertir usuarios con roles globales individuales a roles base normales: usuarios cuyo role sea "individual_teacher" pasar√°n a "teacher", y "individual_student" pasar√°n a "student". Asimismo, si existiera alg√∫n usuario con role: "super_admin" o role: "system", as√≠gneles un rol v√°lido (por ejemplo, "admin" para un super-admin global) o elim√≠nelos si solo eran t√©cnicos. Aseg√∫rese de que ning√∫n usuario quede con roles obsoletos tras la migraci√≥n.
Extender Modelo InstituteMember para Workspaces:
Nuevo Campos en Membership: En la colecci√≥n institute_members, agregue campos para soportar la abstracci√≥n de workspace:
workspace_type: Tipo de contexto de trabajo, por ejemplo "INSTITUTE" (miembro institucional), "INDIVIDUAL_TEACHER" (docente particular) o "INDIVIDUAL_STUDENT" (alumno autodidacta).
workspace_name: Nombre descriptivo del workspace. Para workspaces institucionales puede no ser necesario almacenarlo (el nombre del instituto ya existe), pero para workspaces individuales s√≠ ‚Äì e.g., "Aprendizaje de {Nombre}" para un estudiante independiente o "Clases Particulares de {Nombre}" para un profesor independiente. Esto facilitar√° mostrar el contexto en la UI.
class_id (opcional): En workspaces de tipo INDIVIDUAL_TEACHER, almacene aqu√≠ el _id de la ‚Äúclase personal‚Äù del profesor. De este modo se liga directamente la membres√≠a con la clase √∫nica que maneja ese profesor particular.
Modelo de Datos: Actualice la clase de modelo InstituteMember (o maneje el dict directamente) para incluir estos nuevos campos en to_dict. Por defecto, asigne: workspace_type = "INSTITUTE" para todas las membres√≠as existentes a academias, y para las nuevas entradas individuales asignar seg√∫n corresponda.
Relaci√≥n Usuario‚ÄìInstituto: Relaje la restricci√≥n de unicidad de usuario por instituto si existiera. Actualmente, al agregar un miembro se verifica que el usuario no pertenezca ya a ese instituto
GitHub
. Para soportar que un mismo usuario tenga dos membres√≠as distintas en el instituto gen√©rico (una como estudiante individual y otra como profesor particular), se debe permitir m√∫ltiples entries con igual institute_id mientras el par (user, workspace_type) sea √∫nico. Esto puede implicar ajustar √≠ndices √∫nicos o cambiar la l√≥gica de MembershipService.add_institute_member. Alternativamente, si mantener la unicidad por instituto fuera deseable, podr√≠a optarse por usar una nueva colecci√≥n workspaces; sin embargo, dado que se prefiere minimizar cambios reutilizando las colecciones existentes, es m√°s simple permitir m√∫ltiples membres√≠as en el instituto gen√©rico.
Migraci√≥n de Datos ‚Äì Membres√≠as: Escriba un script de migraci√≥n que actualice todas las entradas de institute_members existentes:
Agregue el campo workspace_type en cada documento. Para cada membership en un instituto no gen√©rico, setee workspace_type = "INSTITUTE". Para cada membership asociada al instituto gen√©rico ‚ÄúAcademia Sapiens‚Äù (ID gen√©rico), determine el tipo seg√∫n su rol actual: si role es "teacher" (o "individual_teacher" previo a la conversi√≥n) entonces workspace_type = "INDIVIDUAL_TEACHER"; si role es "student" (o antes "individual_student"), entonces workspace_type = "INDIVIDUAL_STUDENT".
Actualice el campo role de las memberships individuales: las entradas con role: "individual_teacher" pasarlas a role: "teacher", y "individual_student" a role: "student". As√≠, tras la migraci√≥n la columna role tendr√° solo roles b√°sicos v√°lidos en todas las filas, mientras que workspace_type diferenciar√° el contexto.
Agregue workspace_name en membres√≠as individuales para personalizar la etiqueta. Por ejemplo, podr√≠a ser "Aprendizaje de {Nombre}" usando el nombre del usuario para estudiantes individuales, y "Clase Personal de {Nombre}" para docentes (o alguna variante m√°s breve seg√∫n decida en UI). Nota: Este campo es principalmente para comodidad; alternativamente, el nombre se puede generar din√°micamente en la respuesta del endpoint. El usuario ha indicado que en algunos casos ser√° el nombre del instituto ‚Äì es decir, para workspaces de tipo INSTITUTE el nombre debe ser simplemente el del instituto asociado, mientras que para workspaces individuales se usar√° un nombre descriptivo especial.
Para profesores individuales existentes: rellenar el campo class_id. Localice la clase personal creada para ese profesor (buscando en classes aquella cuyo name coincida con "Clase Personal de {Nombre}" o cuyo created_by sea el user_id en el instituto gen√©rico) y obtenga su _id. Inserte ese _id en institute_members.class_id del membership correspondiente. De este modo, la relaci√≥n entre el workspace del profesor particular y su clase √∫nica queda expl√≠cita. Si alg√∫n profesor independiente no tiene a√∫n su clase personal (en teor√≠a register_user ya la creaba), considere crearla durante la migraci√≥n para consistencia.
Crear Workspaces por Defecto al Registrar Usuarios:
Refactorice el m√©todo de registro de usuarios (UserService.register_user) para generar siempre las membres√≠as correspondientes, en lugar de depender de roles INDIVIDUAL. En concreto:
Registro de Estudiante (rol base STUDENT): Tras insertar el usuario, obtenga/cree las entidades gen√©ricas mediante GenericAcademicService.get_or_create_generic_entities()
GitHub
. Luego cree una entrada en institute_members asociando el usuario al instituto gen√©rico con role: "student", workspace_type: "INDIVIDUAL_STUDENT", y guarde la fecha de ingreso. Esto garantiza que todo estudiante tenga un workspace personal autodidacta. (En el esquema anterior, un usuario estudiante sin instituto no ten√≠a ninguna entrada en institute_members; ahora s√≠ la tendr√°, representando su espacio individual).
Registro de Profesor (rol base TEACHER): Similar al caso anterior, cree dos workspaces por defecto:
Workspace de aprendizaje personal: a√±adir el usuario al instituto gen√©rico con rol "student" y tipo "INDIVIDUAL_STUDENT". As√≠, aunque su rol principal sea docente, tambi√©n obtiene un espacio para estudiar cursos por su cuenta.
Workspace de profesor particular: a√±adir una segunda entrada en institute_members con institute_id gen√©rico, role: "teacher", workspace_type: "INDIVIDUAL_TEACHER". Inmediatamente crear la ‚ÄúClase Personal de {Nombre}‚Äù usando las entidades gen√©ricas (nivel, periodo, materia, secci√≥n gen√©rica)
GitHub
. Registre esa clase mediante ClassService.create_class (como ya se hac√≠a) y obtenga su class_id. Despu√©s de crearla, actualice el membership INDIVIDUAL_TEACHER del usuario para setear el campo class_id con el ID retornado. Loguee o maneje errores si la clase no se pudiera crear, pero el flujo de registro contin√∫a aunque falle la creaci√≥n de la clase (similar a la l√≥gica actual
GitHub
).
Registro de Admin de Instituto (rol base INSTITUTE_ADMIN): Conserve la l√≥gica existente de creaci√≥n de un nuevo instituto y asignaci√≥n del usuario como INSTITUTE_ADMIN
GitHub
. Adem√°s, otorgue tambi√©n los workspaces individuales por defecto: tras crear su instituto, a√±ada el workspace INDIVIDUAL_STUDENT para que el admin tenga un espacio personal de estudiante (y opcionalmente, podr√≠a otorgarse tambi√©n uno INDIVIDUAL_TEACHER si se desea que pueda impartir clases particulares). El stakeholder indic√≥ ‚Äúsolo para los teacher‚Äù respecto al workspace de profesor particular en la migraci√≥n, por lo que en registro de INSTITUTE_ADMIN podemos omitir el INDIVIDUAL_TEACHER y solo darles el de estudiante personal. En resumen, todos los usuarios, sin importar el rol base, recibir√°n siempre una membres√≠a de estudiante individual; y adicionalmente los roles base teacher (y posiblemente institute_admin, bajo criterio) reciben la de profesor individual.
Perfil y Permisos: La creaci√≥n de perfiles de usuario (cognitivo/rol) puede mantenerse usando el rol base como antes
GitHub
. No se necesitan cambios mayores aqu√≠, ya que el perfil base del usuario (teacher/student) seguir√° existiendo. Solo hay que asegurarse de que el backend no intente crear perfiles para roles ‚Äúindividual_*‚Äù ya eliminados ‚Äì con el cambio anterior, eso se evita.
Endpoints REST de Workspaces:
Implemente un conjunto de endpoints gen√©ricos para que el frontend obtenga y cambie el contexto activo sin basarse en ‚Äúinstitutos‚Äù globales:
GET /api/workspaces: Devuelve la lista de todos los workspaces del usuario autenticado. Incluya por cada entrada: un identificador √∫nico de workspace (puede ser simplemente el _id de la membership en institute_members), el workspace_type, el nombre legible (workspace_name), el role_in_workspace (que esencialmente es el campo role de la membership) y metadatos √∫tiles. Para workspaces de tipo INSTITUTE, incluya tambi√©n los datos b√°sicos del instituto (p. ej. nombre, estado) ‚Äì esto se puede lograr uniendo con la colecci√≥n institutes como hac√≠a get_user_institutes antes
GitHub
. Para workspaces individuales, en vez del nombre del instituto gen√©rico, use el workspace_name personalizado (por ejemplo ‚ÄúAprendizaje de Luis‚Äù en lugar de ‚ÄúAcademia Sapiens‚Äù). Aseg√∫rese de que ambos contextos individuales de un mismo usuario en el gen√©rico aparezcan por separado. Nota: En la implementaci√≥n previa MembershipService.get_user_institutes agrupaba las membres√≠as por institute, combinando la info de rol en cada instituto
GitHub
. Esa l√≥gica no distingue dos roles en el mismo instituto (gen√©rico) ‚Äì podr√≠a sobrescribir uno con otro. Por tanto, cree una nueva funci√≥n (p. ej. get_user_workspaces) que no colapse por institute_id, sino que retorne una entrada por cada membres√≠a. En pseudoc√≥digo: memberships = db.institute_members.find({user_id}), luego para cada membership formar un objeto con: id = _id, type = workspace_type, role = role (posiblemente renombrado como role_in_workspace), institute_id y name = (workspace_name o nombre del instituto)
GitHub
GitHub
.
POST /api/workspaces/switch/<workspace_id>: Permite cambiar el contexto activo del usuario. Al invocar, verificar que el <workspace_id> dado corresponde a una membership del usuario (buscar en institute_members por _id y user_id). Si no existe o no pertenece al usuario, devolver 403. Si es v√°lido, generar un nuevo JWT de acceso con las claims actualizadas para ese workspace. Incluya en las claims al menos el identificador del workspace (p. ej. workspace_id: ...). Tambi√©n puede incluir el institute_id asociado y el rol en este workspace para usar en backend o frontend seg√∫n necesidades. Por ejemplo, claims = {"workspace_id": ..., "institute_id": ..., "workspace_role": ...}. Devolver el nuevo token en la respuesta. En esencia, este endpoint reemplaza a /api/users/switch-institute ‚Äì ya no cambia solo el instituto sino el contexto completo.
JWT y Autorizaci√≥n: Decidir c√≥mo manejar las claims de rol en el token. Una opci√≥n segura es no confiar en el rol base global, sino poner en el token el rol espec√≠fico del workspace activo. As√≠, si un usuario con rol base TEACHER cambia a un workspace donde es estudiante, el JWT podr√≠a llevar "workspace_role": "student" y el backend sabr√° que en esta sesi√≥n act√∫a como estudiante. Se puede tambi√©n sobrescribir la claim "role" existente con el rol del workspace para simplificar compatibilidad con el decorador actual. Sin embargo, tenga en cuenta que el decorador @role_required actualmente consulta el campo user.role de la base de datos
GitHub
 (rol base) y luego verifica membres√≠as solo si se pasa institute_id como par√°metro en la ruta
GitHub
. Recomendado: actualizar ligeramente el decorador para contemplar la claim de workspace_role o workspace_id: si el token incluye workspace_id, se podr√≠a resolver internamente la membership y determinar permisos sin requerir siempre el par√°metro en la ruta. Esto ser√≠a un refactor mayor; como soluci√≥n m√≠nima, puede seguir usando institute_id en el token (como antes) para queries y agregar tambi√©n una claim de rol de workspace. El enfoque m√°s sencillo es: mantener institute_id en el token (necesario para filtrar datos por instituto en muchos servicios) y a√±adir role (actualizado al rol en el workspace). Es decir, cuando el usuario cambia, ajustar claims["role"] = membership.role en vez de siempre el global. De esta forma, el JWT de un profesor en su espacio de alumno llevar√≠a role ‚Äústudent‚Äù. El resultado es que el frontend y los decoradores ver√°n al usuario con ese rol durante esa sesi√≥n. (Este cambio requiere tambi√©n que el frontend actualice la cookie/estado de role tras el switch ‚Äì se detalla adelante).
POST /api/workspaces/<id>/study-plan (futuro, Opcional): Prepare un endpoint para que, estando en un workspace individual de estudiante, se pueda iniciar la generaci√≥n de un plan de estudio personal. Por ejemplo, podr√≠a aceptar un payload con un documento PDF o una descripci√≥n de objetivos, y el backend crear√≠a un StudyPlan y un VirtualModule asociado a ese workspace. Este endpoint invocar√≠a la l√≥gica de generaci√≥n autom√°tica que ya existe para cursos institucionales (los ‚Äúgeneradores progresivos‚Äù de m√≥dulos virtuales) pero aplicados al contexto individual (quiz√°s utilizando el instituto gen√©rico como entorno pero aislando el plan para ese usuario). Deje este endpoint listo o al menos esbozado para futuras implementaciones, de modo que el frontend pueda llamarlo cuando el usuario independiente solicite un curso personalizado.
Ajustes en L√≥gica de Permisos y Consultas con Workspaces:
La introducci√≥n de workspaces individuales implica revisar c√≥mo se filtran datos seg√∫n el contexto:
Consultas con institute_id: Muchos servicios (clases, contenidos, etc.) filtran por institute_id asumiendo que un usuario solo ve datos de un instituto a la vez (tomado del token). Esto sigue siendo cierto, ya que el token llevar√° un institute_id activo. Sin embargo, en el caso del instituto gen√©rico, un usuario puede tener m√∫ltiples roles. Se debe prevenir que un profesor independiente pueda ver datos ajenos de otros individuos. Por ejemplo, si hace una petici√≥n de listar clases del instituto gen√©rico, sin m√°s filtros ver√≠a todas las clases de ‚ÄúAcademia Sapiens‚Äù (todas las clases personales de otros profesores). Para evitarlo, implemente una restricci√≥n adicional en dichas consultas cuando institute_id corresponda al gen√©rico:
Si el usuario est√° en un workspace INDIVIDUAL_TEACHER, filtrar las clases del gen√©rico donde created_by sea el user_id o cuyo _id coincida con class_id de su membership. B√°sicamente, limitar a su ‚Äúclase personal‚Äù.
Si el usuario est√° en workspace INDIVIDUAL_STUDENT, filtrar cualquier recurso del gen√©rico a solo aquellos asociados a su plan de estudio o cursos personales. (Actualmente, un estudiante independiente no tiene cursos compartidos, solo su propio plan una vez creado). Se puede, por ejemplo, registrar en alg√∫n lugar la relaci√≥n user‚Äìstudy_plan o user‚Äìvirtual_module generado y usarla para filtrar m√≥dulos/cursos. En principio, al no haber m√∫ltiples cursos en el gen√©rico, este caso es simple: el estudiante individual solo deber√≠a acceder a su contenido.
Decoradores de Rol: Como se mencion√≥, considere actualizar el decorador role_required para que, si el token tiene workspace_id o un workspace_role, utilice esa informaci√≥n en vez del user.role global para autorizar. Esto garantizar√° que, por ejemplo, un token de un profesor en modo estudiante no pase por error un check de @role_required('TEACHER'). Una implementaci√≥n sencilla: despu√©s de verify_jwt_in_request, sobreescribir g.user_roles o request.user_role con la claim de rol del workspace (de estar presente). Alternativamente, si reutiliza la misma clave role en claims pero asign√°ndole el rol del workspace, el decorador actual ya lo tomar√≠a en cuenta porque obtiene user = db.users.find_one(...); if user["role"] in all_roles return f()
GitHub
. Pero ojo: esa l√≠nea sigue leyendo de la BD, no del token, por lo que habr√≠a que modificarla para mirar tambi√©n request.jwt_claims['role'] si existe. Deje comentarios claros en el c√≥digo sobre esta distinci√≥n. En suma, ajuste la autorizaci√≥n para que las acciones permitidas correspondan al rol del contexto activo, no solo al rol base del usuario.
Eliminar Endpoints Obsoletos / Mantener Compatibilidad:
Con la introducci√≥n de /api/workspaces, los endpoints anteriores quedan en desuso:
Reemplace las llamadas de frontend a GET /api/users/my-institutes por GET /api/workspaces. Puede inicialmente hacer que /my-institutes delegue internamente a la nueva l√≥gica de workspaces (retornando solo los de tipo INSTITUTE, por ejemplo), pero dado que controlamos ambas partes (front y back), es preferible migrar totalmente al nuevo endpoint y eventualmente retirar /my-institutes.
De igual modo, depreque POST /api/users/switch-institute/<id>. Puede mantenerse temporalmente por compatibilidad llamando a la nueva funci√≥n de switch workspace (buscando la membership de ese user en el instituto dado y comport√°ndose igual). Sin embargo, lo ideal es que el frontend llame directamente a /workspaces/switch/<workspace_id>. Documente esta transici√≥n.
Verifique otros endpoints relacionados que asuman un √∫nico rol global. Por ejemplo, /api/users/check o /api/users/user-info podr√≠an incluir el rol; aseg√∫rese de que siguen devolviendo el rol base del usuario (eso no cambia). Los endpoints de login/registro ya setear√°n el token con un workspace por defecto (generalmente el primero de la lista).
Verificaci√≥n Final y Eficiencia:
Integridad de Academia Sapiens (instituto gen√©rico): Aseg√∫rese de que el GenericAcademicService garantiza la existencia del instituto gen√©rico y sus entidades antes de usarse
GitHub
. En la migraci√≥n inicial, probablemente ya exista si ten√≠an usuarios individuales antes. De no existir en un sistema fresco, la primera invocaci√≥n a registro lo crea. Para evitar duplicados, podr√≠a ejecutar get_or_create_generic_entities() una vez al iniciar la migraci√≥n de datos para crear la ‚ÄúAcademia Sapiens‚Äù si a√∫n no se ha creado.
Script de Migraci√≥n de Usuarios Existentes: El proceso resumido ser√°: para cada usuario en users:
a. Actualizar su role si era individual (como en el punto 2).
b. Obtener sus membres√≠as existentes. Si el usuario no tiene una membership en el instituto gen√©rico con rol estudiante, crearla ahora (workspace INDIVIDUAL_STUDENT). Esto aplica a todos los usuarios excepto quiz√° al rol ADMIN puro. Ejemplo: un estudiante que solo estaba inscrito en una academia ahora obtendr√° adicionalmente una entrada en Academia Sapiens como STUDENT, d√°ndole acceso a ‚ÄúAprendizaje Personal‚Äù.
c. Si el usuario tiene rol base TEACHER (o INSTITUTE_ADMIN, seg√∫n decisi√≥n): verificar si ya tiene membership en gen√©rico con rol teacher. ‚Äì Si era un INDIVIDUAL_TEACHER ya la tiene (aunque con role a convertir); si no (ej. profesor de academia que nunca tuvo cuenta individual), entonces crear una nueva membership en gen√©rico con role "teacher" y tipo "INDIVIDUAL_TEACHER". Luego crear su clase personal (igual que en registro) y guardar class_id.
d. Si el usuario era INSTITUTE_ADMIN y decidimos no darle personal teacher, omitir ese paso; solo aseg√∫rese de crearle la de estudiante.
e. Para cada membership agregada, tambi√©n genere el campo workspace_name adecuado. Puede basarse en plantillas: para estudiantes: "Aprendizaje de {Nombre}"; para profesores: "Clases de {Nombre}" o similar (el usuario mencion√≥ ‚ÄúAprendizaje De Luis‚Äù como ejemplo de naming). Incluso podr√≠a internacionalizar o simplificar (‚ÄúMi Aprendizaje‚Äù, ‚ÄúMis Clases Particulares‚Äù) seg√∫n convenga la UX.
Pruebas y Performance: Tras aplicar la migraci√≥n, compruebe que cada usuario ahora tiene al menos una membership (dos si es profesor, etc.), y que no quedan referencias a roles obsoletos. Revise especialmente la colecci√≥n institute_members para un usuario profesor con m√∫ltiples academias: ahora deber√≠a tener m√∫ltiples entradas (varias tipo INSTITUTE + las individuales). Ejecute casos de prueba donde un usuario cambia de un workspace a otro y luego intenta acceder a recursos: un profesor con workspace estudiante no debe poder crear contenido, etc., mientras que al volver a su workspace docente s√≠. Asimismo, mida que las consultas a√±adidas (por ejemplo, filtrado adicional en clases del gen√©rico) est√©n indexadas adecuadamente (podr√≠a requerir √≠ndice compuesto por institute_id + created_by, etc., para eficiencia dado que el gen√©rico contendr√° muchas clases personales).
Frontend ‚Äì Actualizaciones de UI y Estado para Multi-Workspace
Eliminar Huellas de Roles Obsoletos:
Enums y Checks: Si el frontend defin√≠a enumeraciones o usaba strings para roles "SUPER_ADMIN" o "SYSTEM", qu√≠telos. Por la inspecci√≥n del c√≥digo, la UI no ofrec√≠a esos roles (eran m√°s t√©cnicos). Tambi√©n aseg√∫rese de ya no mostrar roles individuales. En realidad, la p√°gina de registro solo ofrec√≠a Student, Teacher, Institute Admin
GitHub
, as√≠ que no hay opci√≥n de ‚ÄúProfesor independiente‚Äù expl√≠cita. Simplemente no agregue ninguna ‚Äì el usuario que es Teacher y no puso instituto ser√° tratado autom√°ticamente como independiente por el backend, sin que el frontend deba conocer el rol ‚Äúindividual_teacher‚Äù.
Men√∫s de Administraci√≥n: Verifique componentes como el dashboard de Admin donde se listan usuarios por rol
GitHub
. Si aparece alguna categor√≠a extra (e.g. SUPER_ADMIN), puede ignorarse porque ya no habr√° usuarios con ese rol. No obstante, podr√≠a limpiar la visualizaci√≥n para no mostrar un rol desconocido en caso de que apareciera. En resumen, tras la migraci√≥n, las √∫nicas categor√≠as esperadas son student, teacher, institute_admin, admin (y potencialmente ‚Äúparent‚Äù si estuviera planeado).
Contexto Activo y Selector de Workspace:
Estado Global de AuthContext: Ampl√≠e el contexto de autenticaci√≥n para manejar workspaces en lugar de solo instituto. Actualmente, AuthContext almacena instituteId y el role del usuario (que hasta ahora era fijo)
GitHub
. Cambios a introducir:
Mantenga instituteId para compatibilidad, pero introduzca un nuevo estado, por ejemplo currentWorkspaceId o incluso una estructura currentWorkspace que incluya id, tipo y rol actual. Es importante porque, si el usuario tiene m√∫ltiples roles en el gen√©rico, el instituteId por s√≠ solo (p.ej. el ID de Academia Sapiens) no distingue si est√° en modo profesor o alumno.
Al iniciar sesi√≥n/registrarse, continuar almacenando los datos recibidos. Note que tras los cambios, la respuesta de login/registro seguir√° proporcionando un token JWT y el objeto usuario con su rol base. El token inicial incluir√° por defecto el primer workspace del usuario (seg√∫n la l√≥gica de backend, probablemente la membres√≠a creada m√°s recientemente o la primera encontrada). Podr√≠a convenir que el backend elija un orden consistente, por ejemplo: si el usuario pertenece a una academia institucional, usar esa primero; si no, usar el workspace individual. De cualquier forma, el frontend debe manejar la lista completa en cuanto pueda.
Inmediatamente tras login, fetch de workspaces: Antes, el contexto hac√≠a getMyInstitutes solo para profesores
GitHub
. Ahora, para cualquier usuario con posibilidad de m√∫ltiples contextos (pr√°cticamente todos salvo un estudiante puro sin academia), hay que obtener sus workspaces. Llame al nuevo endpoint GET /api/workspaces (por ejemplo mediante un servicio getWorkspaces() similar al viejo getMyInstitutes). Guarde el resultado en estado, e.g. userWorkspaces.
Mostrar Selector solo si necesario: Si userWorkspaces.length > 1, active la bandera showWorkspaceSelector (an√°logo a showInstituteSelector). Un usuario totalmente independiente profesor tendr√° 2 workspaces (independiente alumno y profesor), as√≠ que ver√° selector. Un estudiante sin academias tendr√° 1 (solo su individual) y no lo ver√°. Un profesor que adem√°s pertenece a X academias tendr√° n+2 workspaces (X institutos + su espacio estudiante + su espacio profesor). Todos >1, as√≠ que selector visible.
Determinar Workspace actual: Despu√©s del login, el backend habr√° asignado un workspace activo (mediante el token). Podemos identificar cu√°l es comparando el instituteId claim y quiz√°s el role del token. Alternativamente, el backend podr√≠a devolver expl√≠citamente en el objeto usuario o en la respuesta qu√© workspace fue usado. Si no, el frontend puede asumir que el primer workspace de la lista coincide con el activo (esto ocurrir√° si el backend siempre pone la primera membership como activa, que era el caso original
GitHub
GitHub
). Mejor a√∫n, pida al backend que en POST /login y /register incluya en la data el workspace_id activo o al menos el institute_id y el rol usados, para poder establecerlo exactamente. En el contexto, guarde currentWorkspaceId y quiz√° derive el tipo consultando en la lista.
Actualizar Role en Contexto: Este es un cambio importante: anteriormente, authContext.role era constante (rol base). Ahora, debe reflejar el rol del workspace activo. Por ejemplo, un usuario con rol base TEACHER que cambie a su workspace de estudiante independiente deber√≠a ver las vistas de alumno. Para lograrlo, al hacer switch de workspace (ver abajo) y tambi√©n tras login, ajuste context.role al rol correspondiente al contexto actual. Esto implica que ya no usamos el rol base como fuente √∫nica de verdad para la UI cuando hay m√∫ltiples roles. Podr√≠amos mantener el rol base en otro campo si se quiere (para decidir permisos globales quiz√°s), pero para las vistas, usaremos el rol del workspace. En la pr√°ctica, esto significa que tras login, si el token activo es de tipo ‚Äúteacher en instituto‚Äù, role seguir√° siendo TEACHER; si fuera ‚Äústudent independiente‚Äù, role se pondr√° en STUDENT aunque el user base sea teacher. A su vez, habr√° que almacenar ese rol en cookie para persistencia (actualizar la cookie role cuando cambie el contexto, dado que la app la lee en initAuth).
Componente Header (Navbar): Modifique el men√∫ desplegable actual de institutos para que funcione con workspaces:
En el estado local del Header, reemplazar userInstitutes por userWorkspaces (o reutilizar la variable pero ahora contendr√° objetos de workspace). La useEffect que cargaba institutos con getMyInstitutes
GitHub
 ahora debe usar getWorkspaces. Aseg√∫rese de llamar solo cuando el usuario est√© autenticado (role no nulo) y el componente montado.
Nombre del Workspace actual: La botonera del selector muestra actualmente getCurrentInstituteName() con un icono de edificio
GitHub
. Implementar una funci√≥n similar que dado el currentWorkspaceId (o instituteId + quiz√°s tipo) devuelva el nombre adecuado. Posibles estrategias:
Buscar en userWorkspaces el objeto cuyo id coincida con currentWorkspaceId y usar su name.
O, si seguimos guardando solo instituteId en contexto y no el workspace, tendremos que inferir. Mejor almacenar el objeto workspace completo para evitar ambig√ºedad. Por simplicidad, guarde en contexto tambi√©n currentWorkspaceRole y currentWorkspaceType. As√≠, si el usuario est√° en gen√©rico y tiene dos roles, sabr√° cu√°l est√° activo.
Etiquetas e √çconos: Para entradas de tipo INSTITUTE, siga mostrando el nombre del instituto con el √≠cono de edificio (üè¢). Para Aprendizaje Personal, puede usar un √≠cono de libro abierto üìñ o un sombrero de graduaci√≥n üéì; para Clases Particulares, quiz√° un √≠cono de aula üë•. Estos detalles de UX son opcionales pero ayudan a distinguir visualmente. Por ejemplo, prepodr√≠a mostrarse:
Academia ABC (icono üè¢),
Aprendizaje de Luis (icono üìñ),
Clases de Luis (icono üë•).
El usuario sugiri√≥ usar el nombre de pila en la etiqueta, pero dado que es el propio usuario vi√©ndose a s√≠ mismo, quiz√° ‚ÄúMi Aprendizaje‚Äù / ‚ÄúMis Clases‚Äù sea m√°s intuitivo. En cualquier caso, defina esas cadenas claramente. El campo workspace_name devuelto por el backend puede ya contenerlas para evitar l√≥gica extra en frontend.
Listado y Selecci√≥n: Renderice el dropdown iterando sobre userWorkspaces
GitHub
. Cada bot√≥n de opci√≥n debe llamar a una funci√≥n de manejador pasando el workspace.id (antes pas√°bamos institute.id). Implemente handleWorkspaceSwitch(workspaceId) que:
Cierre el men√∫,
Llame al contexto switchWorkspace(workspaceId),
(Opcional) podr√≠a actualizar inmediatamente el nombre mostrado mientras se completa el cambio, o simplemente confiar en la recarga de p√°gina como se hace ahora.
Elemento Seleccionado: En el dropdown, marque cu√°l workspace est√° activo. Actualmente se compara institute.id === instituteId del contexto
GitHub
 para resaltar y poner check. Ahora use workspace.id === currentWorkspaceId.
Funci√≥n switchWorkspace en AuthContext:
Cree switchWorkspace(workspaceId): Promise<boolean> en authContext (an√°loga a switchInstitute)
GitHub
GitHub
. Esta funci√≥n debe llamar al servicio API correspondiente (p. ej. userService.switchWorkspace(workspaceId) que haga POST /api/workspaces/switch/:id).
Si la respuesta es exitosa y contiene un nuevo token, actualizar en el estado global: token con el nuevo token, currentWorkspaceId (y asociar instituteId si quiere mantenerlo para compatibilidad ‚Äì el backend puede incluirlo en claims), y muy importante actualizar role del contexto al rol de ese workspace. Puede obtener este rol de la respuesta (si el backend la incluy√≥ en el token claims decodificado) o m√°s simplemente, buscar en la lista userWorkspaces el item cuyo id coincida y leer su role.
Actualizar cookies: sobrescriba authToken con el nuevo token, y tambi√©n la cookie role con el nuevo rol, instituteId con el nuevo institute_id (si cambia) o puede guardar incluso workspaceId en una cookie nueva para re-inicializaci√≥n. Esto es necesario para que tras un reload las cookies reflejen el contexto elegido
GitHub
GitHub
. Ejemplo: si un profesor cambia a su espacio estudiante, setear role=STUDENT en cookies; as√≠, en initAuth() al recargar, detectar√° role student y no mostrar√° men√∫ de profesor indebidamente.
Finalmente, puede optar por recargar la p√°gina para limpiar cualquier estado de datos dependiente (el c√≥digo actual recarga tras cambiar instituto
GitHub
). Esto sigue siendo v√°lido, ya que la aplicaci√≥n puede tener SWR caches o estado que depende del contexto. La recarga forzar√° una nueva carga de datos del nuevo workspace.
Nota: Al recargar, el initAuth() usar√° las cookies actualizadas para reconstruir el estado: en particular storedRole ahora podr√≠a ser distinto del rol base. Esto es aceptable porque refleja que el usuario est√° operando en otro rol. En la UI, tras reload, se ejecutar√° la l√≥gica de obtener workspaces de nuevo y armar el selector. Opcionalmente, podr√≠a persistir tambi√©n el workspaceId en localStorage o cookie para resaltar el mismo contexto tras reload sin depender del orden.
Redirecci√≥n seg√∫n Rol: La funci√≥n redirectBasedOnRole en AuthContext y la l√≥gica de handleSuccessfulRegister usan el rol para enviar al usuario a la ruta inicial adecuada
GitHub
GitHub
. Debemos ajustarla para que considere el rol actual del workspace. Por ejemplo, si un usuario teacher inicia sesi√≥n pero su workspace activo por defecto es de estudiante (caso poco com√∫n, posiblemente solo ocurra si no tiene institutos y decidimos arrancarlo en modo estudiante), deber√≠a ir a las rutas de estudiante. Lo m√°s probable es que un teacher con academia entre como teacher a su academia, y un teacher sin academia entre a su workspace teacher personal (ya que quiz√°s prioricemos mostrarle su √°rea para crear cursos). De cualquier modo, aseg√∫rese de llamar a redirectBasedOnRole(currentRole) donde currentRole proviene del contexto (y ya hemos establecido que contexto.role ser√° el del workspace activo). Esto llevar√° al usuario a la p√°gina de dashboard correspondiente (/student/dashboard o /teacher/dashboard, etc.).
Asimismo, en el componente Header, la funci√≥n handleViewProfile que dirige a la p√°gina de perfil dependiendo del rol
GitHub
debe ahora usar el rol actual (si no, un profesor en modo estudiante podr√≠a ir a la p√°gina de perfil de profesor cuando quer√≠a ver su perfil de estudiante). Usar if (role === 'STUDENT') ‚Ä¶ else if (role === 'TEACHER') ‚Ä¶ sigue bien, siempre que role ya se actualice din√°micamente.
Interfaz para Alumno Individual (Workspace INDIVIDUAL_STUDENT):
Brinde soporte en la UI para que los estudiantes autodidactas aprovechen su workspace personal:
Dashboard/Subjects: En el men√∫ lateral de estudiante, puede incluir una entrada espec√≠fica si se quiere (por ejemplo ‚ÄúMi Plan Personal‚Äù). No obstante, podr√≠a reutilizar la p√°gina existente de materias o dashboard para este prop√≥sito:
Si el estudiante est√° en un workspace de tipo INDIVIDUAL_STUDENT (detectable v√≠a contexto), la pantalla de dashboard podr√≠a mostrar una secci√≥n especial indicando que este es su espacio de autoaprendizaje. Por ejemplo: ‚ÄúAprendizaje Personal: Aqu√≠ puedes crear tu propio plan de estudio independiente.‚Äù
Ofrezca un bot√≥n o formulario para iniciar la generaci√≥n de un plan. Esto implicar√≠a permitirle subir un documento de temario o escribir una descripci√≥n de lo que desea aprender. Ese input se enviar√° al endpoint POST /api/workspaces/<id>/study-plan (creado en el paso backend).
Al recibir la respuesta (que idealmente contendr√° un ID de study_plan o curso generado), redirija al estudiante a la vista de ese curso. Es posible que el curso generado se represente internamente como una clase o m√≥dulo virtual. Si ya existe una p√°gina para mostrar el progreso de un curso (p. ej. la vista de m√≥dulos/temas de un curso normal), int√©grela: quiz√°s reutilizando la interfaz de estudiante que ve los contenidos de una clase, pero aplicada a su nueva ‚Äúclase virtual personal‚Äù. En ausencia de eso, puede simplemente notificar ‚ÄúPlan de estudio creado exitosamente‚Äù y listar el contenido b√°sico.
Sin plan a√∫n: Si el estudiante independiente no ha generado ning√∫n plan, la interfaz deber√≠a reflejarlo. Podr√≠a mostrarse un mensaje del tipo ‚ÄúNo perteneces a ninguna clase institucional ni tienes un plan personal activo. Empieza creando tu propio plan de estudio.‚Äù Esto gu√≠a al usuario a usar la funci√≥n.
Progreso personal: Una vez tenga un plan, la UI de estudiante podr√≠a enumerar los m√≥dulos/temas generados e indicar su progreso. Esto ser√≠a similar a c√≥mo un alumno ve los temas de un curso normal, pero aqu√≠ aplicando a su plan. Aseg√∫rese de probar que un estudiante puede completar contenidos y que esos resultados se guardan (deber√≠an, pues el backend reutiliza VirtualTopicContent y ContentResult para individuales tambi√©n).
Manejo de Estado: Es posible que deba almacenar en alg√∫n estado (Contexto o local) la informaci√≥n del study plan personal generado para no refetch cada vez. Sin embargo, dado que estos planes se crean raramente, una simple llamada tras generaci√≥n para obtener detalles est√° bien. Podr√≠a ampliar el servicio courseService o crear un workspaceService con m√©todos: createPersonalPlan(workspaceId, data) y getPersonalPlan(workspaceId) etc., dependiendo de c√≥mo exponga el backend el curso personal (quiz√° como un curso/clase m√°s bajo el instituto gen√©rico).
Interfaz para Profesor Particular (Workspace INDIVIDUAL_TEACHER):
Garantice que los profesores independientes puedan gestionar su clase personal desde el frontend sin confusi√≥n:
Vista de Clases del Profesor: En la UI actual de profesor, existe una p√°gina de ‚ÄúCursos‚Äù o ‚ÄúClases‚Äù (/teacher/courses) que muestra las clases del instituto activo
GitHub
. Confirme c√≥mo lista esas clases: probablemente hace una petici√≥n para obtener todas las clases del instituto (por ejemplo GET /api/classes?institute_id=<active>). Tras los cambios, cuando el profesor est√° en su workspace personal (instituto gen√©rico), esa petici√≥n debe devolverse filtrada a solo su clase (como se ajust√≥ en backend). Aun as√≠, valide en el frontend:
Si la lista de clases llega con una sola entrada (su clase personal), mu√©strela normalmente. Idealmente deber√≠a aparecer con el nombre ‚ÄúClase Personal de {Nombre}‚Äù. El profesor podr√≠a hacer clic para entrar a gestionarla (se abre la vista de contenidos/estudiantes de la clase). Esto deber√≠a funcionar igual que con cualquier clase institucional.
Verifique que funcionalidades dentro de esa clase siguen operando: por ejemplo, agregar material, crear evaluaciones, etc., deber√≠an comportarse igual. No deber√≠a haber diferencias, pues a nivel de datos es una clase normal ligada al instituto gen√©rico.
Consideraci√≥n de Invitaciones: Si el profesor quiere invitar alumnos a su clase personal, use el flujo normal de invitaciones a clase. Cuando un alumno acepte, el backend lo agregar√° a la clase y, gracias a la l√≥gica existente, como parte de eso seguramente se asegurar√° de que el alumno tenga membership en el instituto correspondiente (en este caso, el gen√©rico). Si esa l√≥gica no existiera, habr√≠a que implementarla: es decir, al aceptar una invitaci√≥n a clase en Academia Sapiens, crear una membership para el alumno en dicho instituto (tipo INDIVIDUAL_STUDENT). Esto efectivamente inscribe al alumno como autodidacta en la plataforma (posiblemente duplicando su workspace personal si ya ten√≠a uno ‚Äì ojo con eso: no duplicar, solo usar la existente si la tuviera). En la pr√°ctica, casi todos los usuarios tendr√°n ya su membership gen√©rica despu√©s de la migraci√≥n, as√≠ que simplemente agregar la entrada en class_members bastar√°.
Compruebe que el decorador de permiso de agregar miembros a clase no impida al profesor particular hacerlo. MembershipService.add_class_member exige que el usuario agregado sea miembro del instituto de la clase
GitHub
GitHub
. Como se mencion√≥, esto ser√° cierto tras la migraci√≥n (el alumno invitado tendr√° o se le habr√° creado su membership en Academia Sapiens).
Men√∫ y Navegaci√≥n del Profesor: El men√∫ lateral del profesor no necesita distinguir expl√≠citamente el contexto personal vs institucional; las opciones (Planes de Contenido, Evaluaciones, etc.) aplicar√°n al instituto activo. Sin embargo, podr√≠a ser confuso que un profesor en Academia Sapiens vea ‚ÄúProgramas‚Äù o ‚ÄúEvaluaciones‚Äù ‚Äì ya que en su clase personal no hay m√∫ltiples programas ni cohortes. Podr√≠a optar por ocultar ciertas secciones en contexto INDIVIDUAL_TEACHER: por ejemplo, en getTeacherMenuItems, condicionar que algunas entradas (como ‚ÄúPlan de Contenido‚Äù institucional) solo se muestren si workspace_type === INSTITUTE. Para personal, quiz√°s solo tenga sentido mostrar ‚ÄúMi Clase‚Äù y ‚ÄúRecursos‚Äù generales. Esto no es estrictamente necesario para funcionalidad, pero mejora la UX (evita p√°ginas vac√≠as o irrelevantes en el modo particular). Implementar estas condicionales consultando el AuthContext (que ahora conoce el tipo de workspace actual) en la construcci√≥n del men√∫.
P√°gina de Dashboard del Profesor: Si existe un dashboard con estad√≠sticas, este podr√≠a mostrar m√©tricas combinadas de todas sus clases en un instituto. En el caso del modo particular, solo hay una clase, pero puede haber m√©tricas globales del instituto gen√©rico que no apliquen. Ser√≠a prudente ajustar el dashboard para contexto personal: en vez de ‚ÄúAlumnos totales del instituto‚Äù (que en Academia Sapiens ser√≠an todos los autodidactas de la plataforma), filtrar o recalcular esos n√∫meros para la clase personal √∫nicamente. Esto requerir√≠a endpoints espec√≠ficos o filtrar en frontend los datos de /admin/dashboard o similares si se estaban usando. Si es complejo, una alternativa es ocultar el dashboard en modo particular, o presentar solo estad√≠sticas relevantes (p. ej. n√∫mero de alumnos en tu clase, etc. ‚Äì posiblemente calculable del n√∫mero de miembros de la clase personal). En esta fase, puede bastar con ocultar datos enga√±osos para no retrasar la entrega.
QA: Flujo Completo Multi-Contexto:
Finalmente, teste el sistema de forma exhaustiva desde el frontend:
Registro: Registrar un estudiante nuevo (deber√≠a autom√°ticamente loguearlo en su workspace individual; verificar que ve su entorno personal correctamente). Registrar un profesor nuevo (sin academia): tras registro, debe ver quiz√°s su clase personal o una indicaci√≥n para crear curso ‚Äì validar que tiene ambos roles disponibles en el selector y que puede alternar. Registrar un institute_admin nuevo: deber√≠a llevarlo a crear su instituto y luego permitirle cambiar a su espacio personal estudiante si lo desea.
Cambio de Workspace: Con un usuario que tenga m√∫ltiples opciones, probar el dropdown. Ejemplo: Usuario con rol base teacher invitado a 1 academia. Al loguear, deber√≠a entrar a la academia por defecto (asumiendo que as√≠ lo definimos). Desde el header, seleccionar ‚ÄúAprendizaje Personal‚Äù => la app deber√≠a refrescar y ahora mostrar la vista de alumno independiente (men√∫ de estudiante, etc.). Comprobar que puede crear un plan y luego volver a ‚ÄúAcademia X‚Äù y retomar su vista de profesor. Tambi√©n, si corresponde, probar ir a ‚ÄúClases Particulares‚Äù y verificar la transici√≥n a vista profesor para su clase personal. Cada cambio de contexto debe actualizar correctamente el estado (cookies, AuthContext) y la UI.
Seguridad: Intente acceder a URLs directamente cambiando el contexto. Por ejemplo, con un token de estudiante personal, acceder a una ruta de profesor (/teacher/dashboard) deber√≠a redirigir o no mostrar contenido (dado que el token ya no tiene permisos). Igualmente, con un token de profesor en academia, acceder a /student/dashboard no deber√≠a mostrar nada √∫til porque no est√° en modo alumno. Lo ideal es que el frontend en s√≠ evite mostrar links/p√°ginas fuera del rol actual, pero asegurarse de que el backend tambi√©n lo restringe (e.g. un estudiante que intente llamar un API de profesor recibir√° 403).
Consistencia de Datos: Verifique que datos como listas de clases, listas de cursos, etc., cambian seg√∫n el workspace. Un mismo usuario en distintos contextos deber√≠a recibir datos distintos apropiadamente: p. ej., en modo estudiante de Academia X ver√° sus cursos matriculados all√≠; en modo estudiante individual ver√° su plan (o nada si no ha creado); en modo profesor Academia X ver√° sus clases de ese instituto; en modo profesor particular ver√° solo su clase personal. Todos estos escenarios deben reflejarse correctamente.
Experiencia de Usuario: Aseg√∫rese que la terminolog√≠a y las indicaciones sean claras para el usuario final. Puede ser conveniente renombrar ‚ÄúInstituto‚Äù por ‚ÄúEspacio‚Äù o ‚ÄúContexto‚Äù en la UI, ya que ahora el dropdown incluye elementos que no son instituciones. Por simplicidad, podr√≠a mantenerse el icono de edificio para abrir el men√∫ pero, por ejemplo, cambiar el tooltip de ‚ÄúCambiar Instituto‚Äù a ‚ÄúCambiar de Modo‚Äù o ‚ÄúCambiar Espacio de Trabajo‚Äù. Peque√±os cambios de texto ayudar√°n a la comprensi√≥n.
Siguiendo estos pasos, el sistema quedar√° simplificado a nivel de roles globales y a la vez m√°s poderoso: cualquier usuario tendr√° un √∫nico rol base pero podr√° desempe√±ar m√∫ltiples papeles seg√∫n el workspace seleccionado. La implementaci√≥n reutiliza en su mayor√≠a las colecciones y l√≥gica existente (e.g. usamos institute_members extendido en lugar de crear todo desde cero) para minimizar cambios disruptivos. Aun as√≠, cubre la funcionalidad deseada: se eliminan roles innecesarios, se evita tener que crear cuentas duplicadas, y se sientan las bases para que un profesor maneje varias academias y su tutor√≠a personal dentro de una misma sesi√≥n de forma coherente
GitHub
GitHub
. Cada secci√≥n del frontend consumir√° los nuevos endpoints de workspaces y adaptar√° la vista seg√∫n el tipo de contexto activo, brindando una experiencia fluida y segura al usuario final.