Plan de Implementación: Eliminación de Roles Obsoletos y Modelo de Workspaces
Backend – Refactorización de Roles y Modelo de Datos
Eliminar Roles SYSTEM y SUPER_ADMIN:
Constantes y Seeds: Remueva las entradas "SUPER_ADMIN" y "SYSTEM" del diccionario de roles en el código backend
GitHub
, así como cualquier referencia a estos roles en datos precargados (seeds/fixtures) o configuraciones. Por ejemplo, en las rutas de corrección el endpoint de procesamiento en cola actualmente exige el rol SYSTEM
GitHub
; ajústelo para que solo requiera un rol administrativo válido (p. ej. ADMIN) o implemente otra forma segura de invocarlo (como un token de servicio protegido por secret).
Validaciones y Permisos: Recorrer todo el código buscando SUPER_ADMIN/SYSTEM (p. ej. decoradores @role_required o lógica condicional) y eliminar esas condiciones o sustituirlas por roles existentes. Dado que estos roles no se usan activamente en la aplicación, su eliminación no debería romper flujos lógicos. Asegúrese de actualizar cualquier lógica de “usuario de sistema” a usar alternativas (un rol ADMIN o un proceso cron externo según corresponda).
Unificar Roles Base (eliminar INDIVIDUAL_ globales):*
Constantes de Rol: Elimine INDIVIDUAL_TEACHER e INDIVIDUAL_STUDENT de la definición global de roles
GitHub
. Estos ya no serán roles principales en la colección users, sino que pasarán a representarse como tipos de workspace.
Referencias en Código: Actualice cualquier chequeo if user.role == 'individual_teacher' o similar. Por ejemplo, en el registro de usuarios actualmente se detectan esos roles para lógica especial
GitHub
; dicha lógica se trasladará (ver siguiente punto). Tras el refactor, los usuarios solo tendrán roles base como "STUDENT", "TEACHER", "INSTITUTE_ADMIN" o "ADMIN". Esto simplifica los permisos generales.
Datos Existentes – Usuarios: Diseñe una migración para convertir usuarios con roles globales individuales a roles base normales: usuarios cuyo role sea "individual_teacher" pasarán a "teacher", y "individual_student" pasarán a "student". Asimismo, si existiera algún usuario con role: "super_admin" o role: "system", asígneles un rol válido (por ejemplo, "admin" para un super-admin global) o elimínelos si solo eran técnicos. Asegúrese de que ningún usuario quede con roles obsoletos tras la migración.
Extender Modelo InstituteMember para Workspaces:
Nuevo Campos en Membership: En la colección institute_members, agregue campos para soportar la abstracción de workspace:
workspace_type: Tipo de contexto de trabajo, por ejemplo "INSTITUTE" (miembro institucional), "INDIVIDUAL_TEACHER" (docente particular) o "INDIVIDUAL_STUDENT" (alumno autodidacta).
workspace_name: Nombre descriptivo del workspace. Para workspaces institucionales puede no ser necesario almacenarlo (el nombre del instituto ya existe), pero para workspaces individuales sí – e.g., "Aprendizaje de {Nombre}" para un estudiante independiente o "Clases Particulares de {Nombre}" para un profesor independiente. Esto facilitará mostrar el contexto en la UI.
class_id (opcional): En workspaces de tipo INDIVIDUAL_TEACHER, almacene aquí el _id de la “clase personal” del profesor. De este modo se liga directamente la membresía con la clase única que maneja ese profesor particular.
Modelo de Datos: Actualice la clase de modelo InstituteMember (o maneje el dict directamente) para incluir estos nuevos campos en to_dict. Por defecto, asigne: workspace_type = "INSTITUTE" para todas las membresías existentes a academias, y para las nuevas entradas individuales asignar según corresponda.
Relación Usuario–Instituto: Relaje la restricción de unicidad de usuario por instituto si existiera. Actualmente, al agregar un miembro se verifica que el usuario no pertenezca ya a ese instituto
GitHub
. Para soportar que un mismo usuario tenga dos membresías distintas en el instituto genérico (una como estudiante individual y otra como profesor particular), se debe permitir múltiples entries con igual institute_id mientras el par (user, workspace_type) sea único. Esto puede implicar ajustar índices únicos o cambiar la lógica de MembershipService.add_institute_member. Alternativamente, si mantener la unicidad por instituto fuera deseable, podría optarse por usar una nueva colección workspaces; sin embargo, dado que se prefiere minimizar cambios reutilizando las colecciones existentes, es más simple permitir múltiples membresías en el instituto genérico.
Migración de Datos – Membresías: Escriba un script de migración que actualice todas las entradas de institute_members existentes:
Agregue el campo workspace_type en cada documento. Para cada membership en un instituto no genérico, setee workspace_type = "INSTITUTE". Para cada membership asociada al instituto genérico “Academia Sapiens” (ID genérico), determine el tipo según su rol actual: si role es "teacher" (o "individual_teacher" previo a la conversión) entonces workspace_type = "INDIVIDUAL_TEACHER"; si role es "student" (o antes "individual_student"), entonces workspace_type = "INDIVIDUAL_STUDENT".
Actualice el campo role de las memberships individuales: las entradas con role: "individual_teacher" pasarlas a role: "teacher", y "individual_student" a role: "student". Así, tras la migración la columna role tendrá solo roles básicos válidos en todas las filas, mientras que workspace_type diferenciará el contexto.
Agregue workspace_name en membresías individuales para personalizar la etiqueta. Por ejemplo, podría ser "Aprendizaje de {Nombre}" usando el nombre del usuario para estudiantes individuales, y "Clase Personal de {Nombre}" para docentes (o alguna variante más breve según decida en UI). Nota: Este campo es principalmente para comodidad; alternativamente, el nombre se puede generar dinámicamente en la respuesta del endpoint. El usuario ha indicado que en algunos casos será el nombre del instituto – es decir, para workspaces de tipo INSTITUTE el nombre debe ser simplemente el del instituto asociado, mientras que para workspaces individuales se usará un nombre descriptivo especial.
Para profesores individuales existentes: rellenar el campo class_id. Localice la clase personal creada para ese profesor (buscando en classes aquella cuyo name coincida con "Clase Personal de {Nombre}" o cuyo created_by sea el user_id en el instituto genérico) y obtenga su _id. Inserte ese _id en institute_members.class_id del membership correspondiente. De este modo, la relación entre el workspace del profesor particular y su clase única queda explícita. Si algún profesor independiente no tiene aún su clase personal (en teoría register_user ya la creaba), considere crearla durante la migración para consistencia.
Crear Workspaces por Defecto al Registrar Usuarios:
Refactorice el método de registro de usuarios (UserService.register_user) para generar siempre las membresías correspondientes, en lugar de depender de roles INDIVIDUAL. En concreto:
Registro de Estudiante (rol base STUDENT): Tras insertar el usuario, obtenga/cree las entidades genéricas mediante GenericAcademicService.get_or_create_generic_entities()
GitHub
. Luego cree una entrada en institute_members asociando el usuario al instituto genérico con role: "student", workspace_type: "INDIVIDUAL_STUDENT", y guarde la fecha de ingreso. Esto garantiza que todo estudiante tenga un workspace personal autodidacta. (En el esquema anterior, un usuario estudiante sin instituto no tenía ninguna entrada en institute_members; ahora sí la tendrá, representando su espacio individual).
Registro de Profesor (rol base TEACHER): Similar al caso anterior, cree dos workspaces por defecto:
Workspace de aprendizaje personal: añadir el usuario al instituto genérico con rol "student" y tipo "INDIVIDUAL_STUDENT". Así, aunque su rol principal sea docente, también obtiene un espacio para estudiar cursos por su cuenta.
Workspace de profesor particular: añadir una segunda entrada en institute_members con institute_id genérico, role: "teacher", workspace_type: "INDIVIDUAL_TEACHER". Inmediatamente crear la “Clase Personal de {Nombre}” usando las entidades genéricas (nivel, periodo, materia, sección genérica)
GitHub
. Registre esa clase mediante ClassService.create_class (como ya se hacía) y obtenga su class_id. Después de crearla, actualice el membership INDIVIDUAL_TEACHER del usuario para setear el campo class_id con el ID retornado. Loguee o maneje errores si la clase no se pudiera crear, pero el flujo de registro continúa aunque falle la creación de la clase (similar a la lógica actual
GitHub
).
Registro de Admin de Instituto (rol base INSTITUTE_ADMIN): Conserve la lógica existente de creación de un nuevo instituto y asignación del usuario como INSTITUTE_ADMIN
GitHub
. Además, otorgue también los workspaces individuales por defecto: tras crear su instituto, añada el workspace INDIVIDUAL_STUDENT para que el admin tenga un espacio personal de estudiante (y opcionalmente, podría otorgarse también uno INDIVIDUAL_TEACHER si se desea que pueda impartir clases particulares). El stakeholder indicó “solo para los teacher” respecto al workspace de profesor particular en la migración, por lo que en registro de INSTITUTE_ADMIN podemos omitir el INDIVIDUAL_TEACHER y solo darles el de estudiante personal. En resumen, todos los usuarios, sin importar el rol base, recibirán siempre una membresía de estudiante individual; y adicionalmente los roles base teacher (y posiblemente institute_admin, bajo criterio) reciben la de profesor individual.
Perfil y Permisos: La creación de perfiles de usuario (cognitivo/rol) puede mantenerse usando el rol base como antes
GitHub
. No se necesitan cambios mayores aquí, ya que el perfil base del usuario (teacher/student) seguirá existiendo. Solo hay que asegurarse de que el backend no intente crear perfiles para roles “individual_*” ya eliminados – con el cambio anterior, eso se evita.
Endpoints REST de Workspaces:
Implemente un conjunto de endpoints genéricos para que el frontend obtenga y cambie el contexto activo sin basarse en “institutos” globales:
GET /api/workspaces: Devuelve la lista de todos los workspaces del usuario autenticado. Incluya por cada entrada: un identificador único de workspace (puede ser simplemente el _id de la membership en institute_members), el workspace_type, el nombre legible (workspace_name), el role_in_workspace (que esencialmente es el campo role de la membership) y metadatos útiles. Para workspaces de tipo INSTITUTE, incluya también los datos básicos del instituto (p. ej. nombre, estado) – esto se puede lograr uniendo con la colección institutes como hacía get_user_institutes antes
GitHub
. Para workspaces individuales, en vez del nombre del instituto genérico, use el workspace_name personalizado (por ejemplo “Aprendizaje de Luis” en lugar de “Academia Sapiens”). Asegúrese de que ambos contextos individuales de un mismo usuario en el genérico aparezcan por separado. Nota: En la implementación previa MembershipService.get_user_institutes agrupaba las membresías por institute, combinando la info de rol en cada instituto
GitHub
. Esa lógica no distingue dos roles en el mismo instituto (genérico) – podría sobrescribir uno con otro. Por tanto, cree una nueva función (p. ej. get_user_workspaces) que no colapse por institute_id, sino que retorne una entrada por cada membresía. En pseudocódigo: memberships = db.institute_members.find({user_id}), luego para cada membership formar un objeto con: id = _id, type = workspace_type, role = role (posiblemente renombrado como role_in_workspace), institute_id y name = (workspace_name o nombre del instituto)
GitHub
GitHub
.
POST /api/workspaces/switch/<workspace_id>: Permite cambiar el contexto activo del usuario. Al invocar, verificar que el <workspace_id> dado corresponde a una membership del usuario (buscar en institute_members por _id y user_id). Si no existe o no pertenece al usuario, devolver 403. Si es válido, generar un nuevo JWT de acceso con las claims actualizadas para ese workspace. Incluya en las claims al menos el identificador del workspace (p. ej. workspace_id: ...). También puede incluir el institute_id asociado y el rol en este workspace para usar en backend o frontend según necesidades. Por ejemplo, claims = {"workspace_id": ..., "institute_id": ..., "workspace_role": ...}. Devolver el nuevo token en la respuesta. En esencia, este endpoint reemplaza a /api/users/switch-institute – ya no cambia solo el instituto sino el contexto completo.
JWT y Autorización: Decidir cómo manejar las claims de rol en el token. Una opción segura es no confiar en el rol base global, sino poner en el token el rol específico del workspace activo. Así, si un usuario con rol base TEACHER cambia a un workspace donde es estudiante, el JWT podría llevar "workspace_role": "student" y el backend sabrá que en esta sesión actúa como estudiante. Se puede también sobrescribir la claim "role" existente con el rol del workspace para simplificar compatibilidad con el decorador actual. Sin embargo, tenga en cuenta que el decorador @role_required actualmente consulta el campo user.role de la base de datos
GitHub
 (rol base) y luego verifica membresías solo si se pasa institute_id como parámetro en la ruta
GitHub
. Recomendado: actualizar ligeramente el decorador para contemplar la claim de workspace_role o workspace_id: si el token incluye workspace_id, se podría resolver internamente la membership y determinar permisos sin requerir siempre el parámetro en la ruta. Esto sería un refactor mayor; como solución mínima, puede seguir usando institute_id en el token (como antes) para queries y agregar también una claim de rol de workspace. El enfoque más sencillo es: mantener institute_id en el token (necesario para filtrar datos por instituto en muchos servicios) y añadir role (actualizado al rol en el workspace). Es decir, cuando el usuario cambia, ajustar claims["role"] = membership.role en vez de siempre el global. De esta forma, el JWT de un profesor en su espacio de alumno llevaría role “student”. El resultado es que el frontend y los decoradores verán al usuario con ese rol durante esa sesión. (Este cambio requiere también que el frontend actualice la cookie/estado de role tras el switch – se detalla adelante).
POST /api/workspaces/<id>/study-plan (futuro, Opcional): Prepare un endpoint para que, estando en un workspace individual de estudiante, se pueda iniciar la generación de un plan de estudio personal. Por ejemplo, podría aceptar un payload con un documento PDF o una descripción de objetivos, y el backend crearía un StudyPlan y un VirtualModule asociado a ese workspace. Este endpoint invocaría la lógica de generación automática que ya existe para cursos institucionales (los “generadores progresivos” de módulos virtuales) pero aplicados al contexto individual (quizás utilizando el instituto genérico como entorno pero aislando el plan para ese usuario). Deje este endpoint listo o al menos esbozado para futuras implementaciones, de modo que el frontend pueda llamarlo cuando el usuario independiente solicite un curso personalizado.
Ajustes en Lógica de Permisos y Consultas con Workspaces:
La introducción de workspaces individuales implica revisar cómo se filtran datos según el contexto:
Consultas con institute_id: Muchos servicios (clases, contenidos, etc.) filtran por institute_id asumiendo que un usuario solo ve datos de un instituto a la vez (tomado del token). Esto sigue siendo cierto, ya que el token llevará un institute_id activo. Sin embargo, en el caso del instituto genérico, un usuario puede tener múltiples roles. Se debe prevenir que un profesor independiente pueda ver datos ajenos de otros individuos. Por ejemplo, si hace una petición de listar clases del instituto genérico, sin más filtros vería todas las clases de “Academia Sapiens” (todas las clases personales de otros profesores). Para evitarlo, implemente una restricción adicional en dichas consultas cuando institute_id corresponda al genérico:
Si el usuario está en un workspace INDIVIDUAL_TEACHER, filtrar las clases del genérico donde created_by sea el user_id o cuyo _id coincida con class_id de su membership. Básicamente, limitar a su “clase personal”.
Si el usuario está en workspace INDIVIDUAL_STUDENT, filtrar cualquier recurso del genérico a solo aquellos asociados a su plan de estudio o cursos personales. (Actualmente, un estudiante independiente no tiene cursos compartidos, solo su propio plan una vez creado). Se puede, por ejemplo, registrar en algún lugar la relación user–study_plan o user–virtual_module generado y usarla para filtrar módulos/cursos. En principio, al no haber múltiples cursos en el genérico, este caso es simple: el estudiante individual solo debería acceder a su contenido.
Decoradores de Rol: Como se mencionó, considere actualizar el decorador role_required para que, si el token tiene workspace_id o un workspace_role, utilice esa información en vez del user.role global para autorizar. Esto garantizará que, por ejemplo, un token de un profesor en modo estudiante no pase por error un check de @role_required('TEACHER'). Una implementación sencilla: después de verify_jwt_in_request, sobreescribir g.user_roles o request.user_role con la claim de rol del workspace (de estar presente). Alternativamente, si reutiliza la misma clave role en claims pero asignándole el rol del workspace, el decorador actual ya lo tomaría en cuenta porque obtiene user = db.users.find_one(...); if user["role"] in all_roles return f()
GitHub
. Pero ojo: esa línea sigue leyendo de la BD, no del token, por lo que habría que modificarla para mirar también request.jwt_claims['role'] si existe. Deje comentarios claros en el código sobre esta distinción. En suma, ajuste la autorización para que las acciones permitidas correspondan al rol del contexto activo, no solo al rol base del usuario.
Eliminar Endpoints Obsoletos / Mantener Compatibilidad:
Con la introducción de /api/workspaces, los endpoints anteriores quedan en desuso:
Reemplace las llamadas de frontend a GET /api/users/my-institutes por GET /api/workspaces. Puede inicialmente hacer que /my-institutes delegue internamente a la nueva lógica de workspaces (retornando solo los de tipo INSTITUTE, por ejemplo), pero dado que controlamos ambas partes (front y back), es preferible migrar totalmente al nuevo endpoint y eventualmente retirar /my-institutes.
De igual modo, depreque POST /api/users/switch-institute/<id>. Puede mantenerse temporalmente por compatibilidad llamando a la nueva función de switch workspace (buscando la membership de ese user en el instituto dado y comportándose igual). Sin embargo, lo ideal es que el frontend llame directamente a /workspaces/switch/<workspace_id>. Documente esta transición.
Verifique otros endpoints relacionados que asuman un único rol global. Por ejemplo, /api/users/check o /api/users/user-info podrían incluir el rol; asegúrese de que siguen devolviendo el rol base del usuario (eso no cambia). Los endpoints de login/registro ya setearán el token con un workspace por defecto (generalmente el primero de la lista).
Verificación Final y Eficiencia:
Integridad de Academia Sapiens (instituto genérico): Asegúrese de que el GenericAcademicService garantiza la existencia del instituto genérico y sus entidades antes de usarse
GitHub
. En la migración inicial, probablemente ya exista si tenían usuarios individuales antes. De no existir en un sistema fresco, la primera invocación a registro lo crea. Para evitar duplicados, podría ejecutar get_or_create_generic_entities() una vez al iniciar la migración de datos para crear la “Academia Sapiens” si aún no se ha creado.
Script de Migración de Usuarios Existentes: El proceso resumido será: para cada usuario en users:
a. Actualizar su role si era individual (como en el punto 2).
b. Obtener sus membresías existentes. Si el usuario no tiene una membership en el instituto genérico con rol estudiante, crearla ahora (workspace INDIVIDUAL_STUDENT). Esto aplica a todos los usuarios excepto quizá al rol ADMIN puro. Ejemplo: un estudiante que solo estaba inscrito en una academia ahora obtendrá adicionalmente una entrada en Academia Sapiens como STUDENT, dándole acceso a “Aprendizaje Personal”.
c. Si el usuario tiene rol base TEACHER (o INSTITUTE_ADMIN, según decisión): verificar si ya tiene membership en genérico con rol teacher. – Si era un INDIVIDUAL_TEACHER ya la tiene (aunque con role a convertir); si no (ej. profesor de academia que nunca tuvo cuenta individual), entonces crear una nueva membership en genérico con role "teacher" y tipo "INDIVIDUAL_TEACHER". Luego crear su clase personal (igual que en registro) y guardar class_id.
d. Si el usuario era INSTITUTE_ADMIN y decidimos no darle personal teacher, omitir ese paso; solo asegúrese de crearle la de estudiante.
e. Para cada membership agregada, también genere el campo workspace_name adecuado. Puede basarse en plantillas: para estudiantes: "Aprendizaje de {Nombre}"; para profesores: "Clases de {Nombre}" o similar (el usuario mencionó “Aprendizaje De Luis” como ejemplo de naming). Incluso podría internacionalizar o simplificar (“Mi Aprendizaje”, “Mis Clases Particulares”) según convenga la UX.
Pruebas y Performance: Tras aplicar la migración, compruebe que cada usuario ahora tiene al menos una membership (dos si es profesor, etc.), y que no quedan referencias a roles obsoletos. Revise especialmente la colección institute_members para un usuario profesor con múltiples academias: ahora debería tener múltiples entradas (varias tipo INSTITUTE + las individuales). Ejecute casos de prueba donde un usuario cambia de un workspace a otro y luego intenta acceder a recursos: un profesor con workspace estudiante no debe poder crear contenido, etc., mientras que al volver a su workspace docente sí. Asimismo, mida que las consultas añadidas (por ejemplo, filtrado adicional en clases del genérico) estén indexadas adecuadamente (podría requerir índice compuesto por institute_id + created_by, etc., para eficiencia dado que el genérico contendrá muchas clases personales).
Frontend – Actualizaciones de UI y Estado para Multi-Workspace
Eliminar Huellas de Roles Obsoletos:
Enums y Checks: Si el frontend definía enumeraciones o usaba strings para roles "SUPER_ADMIN" o "SYSTEM", quítelos. Por la inspección del código, la UI no ofrecía esos roles (eran más técnicos). También asegúrese de ya no mostrar roles individuales. En realidad, la página de registro solo ofrecía Student, Teacher, Institute Admin
GitHub
, así que no hay opción de “Profesor independiente” explícita. Simplemente no agregue ninguna – el usuario que es Teacher y no puso instituto será tratado automáticamente como independiente por el backend, sin que el frontend deba conocer el rol “individual_teacher”.
Menús de Administración: Verifique componentes como el dashboard de Admin donde se listan usuarios por rol
GitHub
. Si aparece alguna categoría extra (e.g. SUPER_ADMIN), puede ignorarse porque ya no habrá usuarios con ese rol. No obstante, podría limpiar la visualización para no mostrar un rol desconocido en caso de que apareciera. En resumen, tras la migración, las únicas categorías esperadas son student, teacher, institute_admin, admin (y potencialmente “parent” si estuviera planeado).
Contexto Activo y Selector de Workspace:
Estado Global de AuthContext: Amplíe el contexto de autenticación para manejar workspaces en lugar de solo instituto. Actualmente, AuthContext almacena instituteId y el role del usuario (que hasta ahora era fijo)
GitHub
. Cambios a introducir:
Mantenga instituteId para compatibilidad, pero introduzca un nuevo estado, por ejemplo currentWorkspaceId o incluso una estructura currentWorkspace que incluya id, tipo y rol actual. Es importante porque, si el usuario tiene múltiples roles en el genérico, el instituteId por sí solo (p.ej. el ID de Academia Sapiens) no distingue si está en modo profesor o alumno.
Al iniciar sesión/registrarse, continuar almacenando los datos recibidos. Note que tras los cambios, la respuesta de login/registro seguirá proporcionando un token JWT y el objeto usuario con su rol base. El token inicial incluirá por defecto el primer workspace del usuario (según la lógica de backend, probablemente la membresía creada más recientemente o la primera encontrada). Podría convenir que el backend elija un orden consistente, por ejemplo: si el usuario pertenece a una academia institucional, usar esa primero; si no, usar el workspace individual. De cualquier forma, el frontend debe manejar la lista completa en cuanto pueda.
Inmediatamente tras login, fetch de workspaces: Antes, el contexto hacía getMyInstitutes solo para profesores
GitHub
. Ahora, para cualquier usuario con posibilidad de múltiples contextos (prácticamente todos salvo un estudiante puro sin academia), hay que obtener sus workspaces. Llame al nuevo endpoint GET /api/workspaces (por ejemplo mediante un servicio getWorkspaces() similar al viejo getMyInstitutes). Guarde el resultado en estado, e.g. userWorkspaces.
Mostrar Selector solo si necesario: Si userWorkspaces.length > 1, active la bandera showWorkspaceSelector (análogo a showInstituteSelector). Un usuario totalmente independiente profesor tendrá 2 workspaces (independiente alumno y profesor), así que verá selector. Un estudiante sin academias tendrá 1 (solo su individual) y no lo verá. Un profesor que además pertenece a X academias tendrá n+2 workspaces (X institutos + su espacio estudiante + su espacio profesor). Todos >1, así que selector visible.
Determinar Workspace actual: Después del login, el backend habrá asignado un workspace activo (mediante el token). Podemos identificar cuál es comparando el instituteId claim y quizás el role del token. Alternativamente, el backend podría devolver explícitamente en el objeto usuario o en la respuesta qué workspace fue usado. Si no, el frontend puede asumir que el primer workspace de la lista coincide con el activo (esto ocurrirá si el backend siempre pone la primera membership como activa, que era el caso original
GitHub
GitHub
). Mejor aún, pida al backend que en POST /login y /register incluya en la data el workspace_id activo o al menos el institute_id y el rol usados, para poder establecerlo exactamente. En el contexto, guarde currentWorkspaceId y quizá derive el tipo consultando en la lista.
Actualizar Role en Contexto: Este es un cambio importante: anteriormente, authContext.role era constante (rol base). Ahora, debe reflejar el rol del workspace activo. Por ejemplo, un usuario con rol base TEACHER que cambie a su workspace de estudiante independiente debería ver las vistas de alumno. Para lograrlo, al hacer switch de workspace (ver abajo) y también tras login, ajuste context.role al rol correspondiente al contexto actual. Esto implica que ya no usamos el rol base como fuente única de verdad para la UI cuando hay múltiples roles. Podríamos mantener el rol base en otro campo si se quiere (para decidir permisos globales quizás), pero para las vistas, usaremos el rol del workspace. En la práctica, esto significa que tras login, si el token activo es de tipo “teacher en instituto”, role seguirá siendo TEACHER; si fuera “student independiente”, role se pondrá en STUDENT aunque el user base sea teacher. A su vez, habrá que almacenar ese rol en cookie para persistencia (actualizar la cookie role cuando cambie el contexto, dado que la app la lee en initAuth).
Componente Header (Navbar): Modifique el menú desplegable actual de institutos para que funcione con workspaces:
En el estado local del Header, reemplazar userInstitutes por userWorkspaces (o reutilizar la variable pero ahora contendrá objetos de workspace). La useEffect que cargaba institutos con getMyInstitutes
GitHub
 ahora debe usar getWorkspaces. Asegúrese de llamar solo cuando el usuario esté autenticado (role no nulo) y el componente montado.
Nombre del Workspace actual: La botonera del selector muestra actualmente getCurrentInstituteName() con un icono de edificio
GitHub
. Implementar una función similar que dado el currentWorkspaceId (o instituteId + quizás tipo) devuelva el nombre adecuado. Posibles estrategias:
Buscar en userWorkspaces el objeto cuyo id coincida con currentWorkspaceId y usar su name.
O, si seguimos guardando solo instituteId en contexto y no el workspace, tendremos que inferir. Mejor almacenar el objeto workspace completo para evitar ambigüedad. Por simplicidad, guarde en contexto también currentWorkspaceRole y currentWorkspaceType. Así, si el usuario está en genérico y tiene dos roles, sabrá cuál está activo.
Etiquetas e Íconos: Para entradas de tipo INSTITUTE, siga mostrando el nombre del instituto con el ícono de edificio (🏢). Para Aprendizaje Personal, puede usar un ícono de libro abierto 📖 o un sombrero de graduación 🎓; para Clases Particulares, quizá un ícono de aula 👥. Estos detalles de UX son opcionales pero ayudan a distinguir visualmente. Por ejemplo, prepodría mostrarse:
Academia ABC (icono 🏢),
Aprendizaje de Luis (icono 📖),
Clases de Luis (icono 👥).
El usuario sugirió usar el nombre de pila en la etiqueta, pero dado que es el propio usuario viéndose a sí mismo, quizá “Mi Aprendizaje” / “Mis Clases” sea más intuitivo. En cualquier caso, defina esas cadenas claramente. El campo workspace_name devuelto por el backend puede ya contenerlas para evitar lógica extra en frontend.
Listado y Selección: Renderice el dropdown iterando sobre userWorkspaces
GitHub
. Cada botón de opción debe llamar a una función de manejador pasando el workspace.id (antes pasábamos institute.id). Implemente handleWorkspaceSwitch(workspaceId) que:
Cierre el menú,
Llame al contexto switchWorkspace(workspaceId),
(Opcional) podría actualizar inmediatamente el nombre mostrado mientras se completa el cambio, o simplemente confiar en la recarga de página como se hace ahora.
Elemento Seleccionado: En el dropdown, marque cuál workspace está activo. Actualmente se compara institute.id === instituteId del contexto
GitHub
 para resaltar y poner check. Ahora use workspace.id === currentWorkspaceId.
Función switchWorkspace en AuthContext:
Cree switchWorkspace(workspaceId): Promise<boolean> en authContext (análoga a switchInstitute)
GitHub
GitHub
. Esta función debe llamar al servicio API correspondiente (p. ej. userService.switchWorkspace(workspaceId) que haga POST /api/workspaces/switch/:id).
Si la respuesta es exitosa y contiene un nuevo token, actualizar en el estado global: token con el nuevo token, currentWorkspaceId (y asociar instituteId si quiere mantenerlo para compatibilidad – el backend puede incluirlo en claims), y muy importante actualizar role del contexto al rol de ese workspace. Puede obtener este rol de la respuesta (si el backend la incluyó en el token claims decodificado) o más simplemente, buscar en la lista userWorkspaces el item cuyo id coincida y leer su role.
Actualizar cookies: sobrescriba authToken con el nuevo token, y también la cookie role con el nuevo rol, instituteId con el nuevo institute_id (si cambia) o puede guardar incluso workspaceId en una cookie nueva para re-inicialización. Esto es necesario para que tras un reload las cookies reflejen el contexto elegido
GitHub
GitHub
. Ejemplo: si un profesor cambia a su espacio estudiante, setear role=STUDENT en cookies; así, en initAuth() al recargar, detectará role student y no mostrará menú de profesor indebidamente.
Finalmente, puede optar por recargar la página para limpiar cualquier estado de datos dependiente (el código actual recarga tras cambiar instituto
GitHub
). Esto sigue siendo válido, ya que la aplicación puede tener SWR caches o estado que depende del contexto. La recarga forzará una nueva carga de datos del nuevo workspace.
Nota: Al recargar, el initAuth() usará las cookies actualizadas para reconstruir el estado: en particular storedRole ahora podría ser distinto del rol base. Esto es aceptable porque refleja que el usuario está operando en otro rol. En la UI, tras reload, se ejecutará la lógica de obtener workspaces de nuevo y armar el selector. Opcionalmente, podría persistir también el workspaceId en localStorage o cookie para resaltar el mismo contexto tras reload sin depender del orden.
Redirección según Rol: La función redirectBasedOnRole en AuthContext y la lógica de handleSuccessfulRegister usan el rol para enviar al usuario a la ruta inicial adecuada
GitHub
GitHub
. Debemos ajustarla para que considere el rol actual del workspace. Por ejemplo, si un usuario teacher inicia sesión pero su workspace activo por defecto es de estudiante (caso poco común, posiblemente solo ocurra si no tiene institutos y decidimos arrancarlo en modo estudiante), debería ir a las rutas de estudiante. Lo más probable es que un teacher con academia entre como teacher a su academia, y un teacher sin academia entre a su workspace teacher personal (ya que quizás prioricemos mostrarle su área para crear cursos). De cualquier modo, asegúrese de llamar a redirectBasedOnRole(currentRole) donde currentRole proviene del contexto (y ya hemos establecido que contexto.role será el del workspace activo). Esto llevará al usuario a la página de dashboard correspondiente (/student/dashboard o /teacher/dashboard, etc.).
Asimismo, en el componente Header, la función handleViewProfile que dirige a la página de perfil dependiendo del rol
GitHub
debe ahora usar el rol actual (si no, un profesor en modo estudiante podría ir a la página de perfil de profesor cuando quería ver su perfil de estudiante). Usar if (role === 'STUDENT') … else if (role === 'TEACHER') … sigue bien, siempre que role ya se actualice dinámicamente.
Interfaz para Alumno Individual (Workspace INDIVIDUAL_STUDENT):
Brinde soporte en la UI para que los estudiantes autodidactas aprovechen su workspace personal:
Dashboard/Subjects: En el menú lateral de estudiante, puede incluir una entrada específica si se quiere (por ejemplo “Mi Plan Personal”). No obstante, podría reutilizar la página existente de materias o dashboard para este propósito:
Si el estudiante está en un workspace de tipo INDIVIDUAL_STUDENT (detectable vía contexto), la pantalla de dashboard podría mostrar una sección especial indicando que este es su espacio de autoaprendizaje. Por ejemplo: “Aprendizaje Personal: Aquí puedes crear tu propio plan de estudio independiente.”
Ofrezca un botón o formulario para iniciar la generación de un plan. Esto implicaría permitirle subir un documento de temario o escribir una descripción de lo que desea aprender. Ese input se enviará al endpoint POST /api/workspaces/<id>/study-plan (creado en el paso backend).
Al recibir la respuesta (que idealmente contendrá un ID de study_plan o curso generado), redirija al estudiante a la vista de ese curso. Es posible que el curso generado se represente internamente como una clase o módulo virtual. Si ya existe una página para mostrar el progreso de un curso (p. ej. la vista de módulos/temas de un curso normal), intégrela: quizás reutilizando la interfaz de estudiante que ve los contenidos de una clase, pero aplicada a su nueva “clase virtual personal”. En ausencia de eso, puede simplemente notificar “Plan de estudio creado exitosamente” y listar el contenido básico.
Sin plan aún: Si el estudiante independiente no ha generado ningún plan, la interfaz debería reflejarlo. Podría mostrarse un mensaje del tipo “No perteneces a ninguna clase institucional ni tienes un plan personal activo. Empieza creando tu propio plan de estudio.” Esto guía al usuario a usar la función.
Progreso personal: Una vez tenga un plan, la UI de estudiante podría enumerar los módulos/temas generados e indicar su progreso. Esto sería similar a cómo un alumno ve los temas de un curso normal, pero aquí aplicando a su plan. Asegúrese de probar que un estudiante puede completar contenidos y que esos resultados se guardan (deberían, pues el backend reutiliza VirtualTopicContent y ContentResult para individuales también).
Manejo de Estado: Es posible que deba almacenar en algún estado (Contexto o local) la información del study plan personal generado para no refetch cada vez. Sin embargo, dado que estos planes se crean raramente, una simple llamada tras generación para obtener detalles está bien. Podría ampliar el servicio courseService o crear un workspaceService con métodos: createPersonalPlan(workspaceId, data) y getPersonalPlan(workspaceId) etc., dependiendo de cómo exponga el backend el curso personal (quizá como un curso/clase más bajo el instituto genérico).
Interfaz para Profesor Particular (Workspace INDIVIDUAL_TEACHER):
Garantice que los profesores independientes puedan gestionar su clase personal desde el frontend sin confusión:
Vista de Clases del Profesor: En la UI actual de profesor, existe una página de “Cursos” o “Clases” (/teacher/courses) que muestra las clases del instituto activo
GitHub
. Confirme cómo lista esas clases: probablemente hace una petición para obtener todas las clases del instituto (por ejemplo GET /api/classes?institute_id=<active>). Tras los cambios, cuando el profesor está en su workspace personal (instituto genérico), esa petición debe devolverse filtrada a solo su clase (como se ajustó en backend). Aun así, valide en el frontend:
Si la lista de clases llega con una sola entrada (su clase personal), muéstrela normalmente. Idealmente debería aparecer con el nombre “Clase Personal de {Nombre}”. El profesor podría hacer clic para entrar a gestionarla (se abre la vista de contenidos/estudiantes de la clase). Esto debería funcionar igual que con cualquier clase institucional.
Verifique que funcionalidades dentro de esa clase siguen operando: por ejemplo, agregar material, crear evaluaciones, etc., deberían comportarse igual. No debería haber diferencias, pues a nivel de datos es una clase normal ligada al instituto genérico.
Consideración de Invitaciones: Si el profesor quiere invitar alumnos a su clase personal, use el flujo normal de invitaciones a clase. Cuando un alumno acepte, el backend lo agregará a la clase y, gracias a la lógica existente, como parte de eso seguramente se asegurará de que el alumno tenga membership en el instituto correspondiente (en este caso, el genérico). Si esa lógica no existiera, habría que implementarla: es decir, al aceptar una invitación a clase en Academia Sapiens, crear una membership para el alumno en dicho instituto (tipo INDIVIDUAL_STUDENT). Esto efectivamente inscribe al alumno como autodidacta en la plataforma (posiblemente duplicando su workspace personal si ya tenía uno – ojo con eso: no duplicar, solo usar la existente si la tuviera). En la práctica, casi todos los usuarios tendrán ya su membership genérica después de la migración, así que simplemente agregar la entrada en class_members bastará.
Compruebe que el decorador de permiso de agregar miembros a clase no impida al profesor particular hacerlo. MembershipService.add_class_member exige que el usuario agregado sea miembro del instituto de la clase
GitHub
GitHub
. Como se mencionó, esto será cierto tras la migración (el alumno invitado tendrá o se le habrá creado su membership en Academia Sapiens).
Menú y Navegación del Profesor: El menú lateral del profesor no necesita distinguir explícitamente el contexto personal vs institucional; las opciones (Planes de Contenido, Evaluaciones, etc.) aplicarán al instituto activo. Sin embargo, podría ser confuso que un profesor en Academia Sapiens vea “Programas” o “Evaluaciones” – ya que en su clase personal no hay múltiples programas ni cohortes. Podría optar por ocultar ciertas secciones en contexto INDIVIDUAL_TEACHER: por ejemplo, en getTeacherMenuItems, condicionar que algunas entradas (como “Plan de Contenido” institucional) solo se muestren si workspace_type === INSTITUTE. Para personal, quizás solo tenga sentido mostrar “Mi Clase” y “Recursos” generales. Esto no es estrictamente necesario para funcionalidad, pero mejora la UX (evita páginas vacías o irrelevantes en el modo particular). Implementar estas condicionales consultando el AuthContext (que ahora conoce el tipo de workspace actual) en la construcción del menú.
Página de Dashboard del Profesor: Si existe un dashboard con estadísticas, este podría mostrar métricas combinadas de todas sus clases en un instituto. En el caso del modo particular, solo hay una clase, pero puede haber métricas globales del instituto genérico que no apliquen. Sería prudente ajustar el dashboard para contexto personal: en vez de “Alumnos totales del instituto” (que en Academia Sapiens serían todos los autodidactas de la plataforma), filtrar o recalcular esos números para la clase personal únicamente. Esto requeriría endpoints específicos o filtrar en frontend los datos de /admin/dashboard o similares si se estaban usando. Si es complejo, una alternativa es ocultar el dashboard en modo particular, o presentar solo estadísticas relevantes (p. ej. número de alumnos en tu clase, etc. – posiblemente calculable del número de miembros de la clase personal). En esta fase, puede bastar con ocultar datos engañosos para no retrasar la entrega.
QA: Flujo Completo Multi-Contexto:
Finalmente, teste el sistema de forma exhaustiva desde el frontend:
Registro: Registrar un estudiante nuevo (debería automáticamente loguearlo en su workspace individual; verificar que ve su entorno personal correctamente). Registrar un profesor nuevo (sin academia): tras registro, debe ver quizás su clase personal o una indicación para crear curso – validar que tiene ambos roles disponibles en el selector y que puede alternar. Registrar un institute_admin nuevo: debería llevarlo a crear su instituto y luego permitirle cambiar a su espacio personal estudiante si lo desea.
Cambio de Workspace: Con un usuario que tenga múltiples opciones, probar el dropdown. Ejemplo: Usuario con rol base teacher invitado a 1 academia. Al loguear, debería entrar a la academia por defecto (asumiendo que así lo definimos). Desde el header, seleccionar “Aprendizaje Personal” => la app debería refrescar y ahora mostrar la vista de alumno independiente (menú de estudiante, etc.). Comprobar que puede crear un plan y luego volver a “Academia X” y retomar su vista de profesor. También, si corresponde, probar ir a “Clases Particulares” y verificar la transición a vista profesor para su clase personal. Cada cambio de contexto debe actualizar correctamente el estado (cookies, AuthContext) y la UI.
Seguridad: Intente acceder a URLs directamente cambiando el contexto. Por ejemplo, con un token de estudiante personal, acceder a una ruta de profesor (/teacher/dashboard) debería redirigir o no mostrar contenido (dado que el token ya no tiene permisos). Igualmente, con un token de profesor en academia, acceder a /student/dashboard no debería mostrar nada útil porque no está en modo alumno. Lo ideal es que el frontend en sí evite mostrar links/páginas fuera del rol actual, pero asegurarse de que el backend también lo restringe (e.g. un estudiante que intente llamar un API de profesor recibirá 403).
Consistencia de Datos: Verifique que datos como listas de clases, listas de cursos, etc., cambian según el workspace. Un mismo usuario en distintos contextos debería recibir datos distintos apropiadamente: p. ej., en modo estudiante de Academia X verá sus cursos matriculados allí; en modo estudiante individual verá su plan (o nada si no ha creado); en modo profesor Academia X verá sus clases de ese instituto; en modo profesor particular verá solo su clase personal. Todos estos escenarios deben reflejarse correctamente.
Experiencia de Usuario: Asegúrese que la terminología y las indicaciones sean claras para el usuario final. Puede ser conveniente renombrar “Instituto” por “Espacio” o “Contexto” en la UI, ya que ahora el dropdown incluye elementos que no son instituciones. Por simplicidad, podría mantenerse el icono de edificio para abrir el menú pero, por ejemplo, cambiar el tooltip de “Cambiar Instituto” a “Cambiar de Modo” o “Cambiar Espacio de Trabajo”. Pequeños cambios de texto ayudarán a la comprensión.
Siguiendo estos pasos, el sistema quedará simplificado a nivel de roles globales y a la vez más poderoso: cualquier usuario tendrá un único rol base pero podrá desempeñar múltiples papeles según el workspace seleccionado. La implementación reutiliza en su mayoría las colecciones y lógica existente (e.g. usamos institute_members extendido en lugar de crear todo desde cero) para minimizar cambios disruptivos. Aun así, cubre la funcionalidad deseada: se eliminan roles innecesarios, se evita tener que crear cuentas duplicadas, y se sientan las bases para que un profesor maneje varias academias y su tutoría personal dentro de una misma sesión de forma coherente
GitHub
GitHub
. Cada sección del frontend consumirá los nuevos endpoints de workspaces y adaptará la vista según el tipo de contexto activo, brindando una experiencia fluida y segura al usuario final.