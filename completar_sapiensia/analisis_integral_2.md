Estado Actual de la Implementaci√≥n y Plan Actualizado
Estado Actual del C√≥digo y Cumplimiento de Requerimientos

**LEYENDA DE ESTADO:**
‚úÖ IMPLEMENTADO - Funcionalidad completamente implementada y funcional
üîÑ PENDIENTE - Funcionalidad pendiente de implementaci√≥n o requiere trabajo adicional
‚úÖ IMPLEMENTADO - M√≥dulos Virtuales Personalizados y Generaci√≥n Progresiva: El backend ya define modelos y l√≥gica para m√≥dulos y temas virtuales. Existe VirtualModule con campos de progreso, estado de generaci√≥n, etc., y VirtualTopic con atributo locked para manejar el bloqueo/desbloqueo de temas[1][2]. La generaci√≥n progresiva en segundo plano est√° implementada mediante una cola de tareas (VirtualGenerationTask). Por ejemplo, el endpoint POST /api/virtual/progressive-generation inicializa la virtualizaci√≥n encolando los primeros m√≥dulos de un plan para un estudiante[3][4], en grupos de hasta 3 m√≥dulos simult√°neamente. De hecho, el c√≥digo encola los primeros m√≥dulos y genera inmediatamente el primero para que el alumno no espere (usando fast_generator.generate_single_module)[5][6]. Tras esto, responde con los IDs de tareas encoladas y el m√≥dulo generado inmediatamente[7]. ‚úÖ IMPLEMENTADO - Tambi√©n est√°n los endpoints POST /api/virtual/trigger-next-topic y /api/virtual/trigger-next-generation para disparar la generaci√≥n del siguiente tema o m√≥dulo cuando el progreso supera 80%[8][9]. En el c√≥digo, estos verifican el progreso m√≠nimo (ej. if progress < 80:) y buscan el siguiente tema o m√≥dulo publicado no generado; si existe, lo encolan con prioridad alta[10][11]. **NOTA: Se corrigi√≥ el bug del trigger-next-topic cambiando la validaci√≥n de progress < 0.8 a progress < 80 y se implement√≥ la funci√≥n trigger_next_topic_generation faltante en VirtualTopicService.** Si no hay m√°s m√≥dulos disponibles, responden indicando que se complet√≥ la generaci√≥n progresiva[12]. En resumen, la cola de generaci√≥n est√° implementada como se requer√≠a: siempre mantiene m√≥dulos/temas futuros listos en segundo plano, con notificaciones en la respuesta sobre la cola (pending, processing, etc.)[7].
‚úÖ IMPLEMENTADO - Contenido Base vs Virtual y Resultados de Contenidos: El backend distingue entre contenidos base del profesor (TopicContent) y contenidos virtuales personalizados por alumno (VirtualTopicContent). Cada VirtualTopicContent mantiene referencia al contenido base original mediante content_id[13][14], y almacena adaptaciones (campo adapted_content o personalization_data). Este dise√±o se refleja en c√≥mo se registran los resultados: el modelo unificado ContentResult guarda content_id apuntando al contenido base en cada resultado[13]. As√≠, si 5 alumnos hacen el mismo quiz base, se crean 5 resultados con el mismo content_id, lo que permite estad√≠sticas globales por contenido[14]. Esto concuerda con la decisi√≥n de dise√±o mencionada en requerimientos. Adem√°s, ya existe un endpoint POST /api/virtual/content-result que recibe los datos de cualquier contenido interactivo completado y crea el ContentResult[15][16]. En ese endpoint se verifica que el contenido virtual existe y pertenece al alumno, luego se invoca ContentResultService.record_result para guardarlo[17]. Tambi√©n se actualiza el interaction_tracking del VirtualTopicContent: por ejemplo, se incrementa el contador de accesos, se marca completion_status en ‚Äúcompleted‚Äù si completion_percentage>=100[18][19]. Incluso el sistema auto-completa los contenidos informativos: hay un endpoint POST /api/virtual/content/<virtual_content_id>/complete-auto que el alumno activa al terminar un texto, video, etc., y este asigna un score autom√°tico (100% para lecturas, etc.) y marca el contenido como visto[20][21]. En el servicio relacionado se utiliza la l√≥gica de VirtualContentProgressService.complete_content_automatically para definir el porcentaje seg√∫n el tipo (por ej., 1.0 para textos, 0.8 juegos, 0 para quizzes)[22]. En s√≠ntesis: la plataforma ya registra los resultados de cada contenido e incluso auto-completa los no evaluativos, cumpliendo con el requerimiento de unificar el seguimiento. Los contenidos virtuales se consideran completados cuando el alumno los revisa o alcanza puntuaci√≥n, y esto genera un ContentResult con score apropiado (100% si solo era visualizaci√≥n)[23][24].
‚úÖ IMPLEMENTADO - Personalizaci√≥n seg√∫n Perfil Cognitivo: La l√≥gica de selecci√≥n de contenidos personalizados est√° implementada. En el backend, la clase FastVirtualModuleGenerator contiene el m√©todo _select_personalized_contents que recibe los contenidos base de un tema y el perfil cognitivo del alumno, y elige un subconjunto √≥ptimo para virtualizar[25][26]. Pruebas unitarias confirman su comportamiento: por ejemplo, para un perfil visual con dislexia, el generador selecciona contenido visual (infograf√≠as, videos) evitando exceso de texto, y siempre incluye al menos un recurso te√≥rico completo[27][28]. Para un perfil kinest√©sico con TDAH, prioriza interactivos (juegos, ejercicios) seg√∫n los puntajes VARK y flags de diagn√≥stico[27][29]. Esta l√≥gica se apoya en reglas codificadas (ej: _select_by_vak_preference y marcadores de accesibilidad). De hecho, el contenido base trae un campo personalization_markers indicando segmentos personalizables (como {{nombre}}), y se implement√≥ un mecanismo para remplazarlos con datos del estudiante[30]. Actualmente, al generar el VirtualTopicContent, el backend marca qu√© adaptaciones aplicar (ej. dyslexia_friendly=True si el perfil lo requiere)[28][31]. El frontend luego podr√≠a usar estas marcas para ajustar la presentaci√≥n (p. ej., fuente especial para dislexia). Si bien esta parte fina de sustituci√≥n de marcadores se estaba simulando, la estructura est√° preparada[32]. En suma, la plataforma no crea contenidos gen√©ricos iguales para todos, sino que filtra y adapta seg√∫n el perfil. Cada tema virtual generado incluye un conjunto de 4‚Äì6 contenidos seleccionados espec√≠ficamente para maximizar el aprendizaje del alumno, cumpliendo la regla de cubrir todo el tema sin redundar[27][33].
üîÑ PENDIENTE - Aprendizaje por Refuerzo y Adaptaci√≥n Continua: A√∫n no est√° completamente operativa, pero se sentaron las bases. Todos los ContentResult almacenan tipo de contenido, puntuaci√≥n, tiempo, etc., en la BD[23][34]. Existe un servicio AdaptiveLearningService (se importa en rutas virtuales[25]) que en el futuro analizar√° estos resultados para ajustar la entrega de contenidos. Si bien por ahora no se realimenta el perfil autom√°ticamente, el dise√±o unificado de resultados lo facilita: por ejemplo, es trivial filtrar todos los resultados de un alumno por tipo de contenido para ver con cu√°les obtiene mejores scores. De hecho, el backend ya ofrece un endpoint GET /api/virtual/content-results/student/<student_id> que devuelve todos los ContentResults de un alumno, con filtros opcionales por tipo o m√≥dulo[35][36]. Este endpoint incluso enriquece cada resultado con informaci√≥n del contenido (tipo, t√≠tulo) y del tema asociado[37][38], indicando que se prev√© usar estos datos para an√°lisis. Conforme se acumulen datos, bastar√° con implementar una funci√≥n que calcule promedios y desv√≠os por tipo de recurso para actualizar el perfil cognitivo (quiz√°s ajustando pesos VARK). En resumen, aunque la adaptaci√≥n por refuerzo es una tarea pendiente de desarrollo, la infraestructura de resultados unificados y endpoints de obtenci√≥n de m√©tricas est√° lista para soportarla.
‚úÖ IMPLEMENTADO - Tipos de Contenido y Variedad: El sistema ya reconoce una amplia variedad de tipos de contenido. En la base de datos, los contenidos tienen un campo content_type y se definieron constantes para m√°s de 30 tipos (texto, video, diapositiva, quiz, juego, simulaci√≥n, flashcards, etc.). Por ejemplo, en el c√≥digo backend (modelo ContentTypes) aparecen valores como "TEXT", "DIAGRAM", "QUIZ", "GAME", "SIMULATION", "GEMINI_LIVE", "EXAM", "PROJECT", etc., cubriendo las categor√≠as te√≥ricas, visuales, interactivas y evaluativas[39]. El flujo de generaci√≥n actual principalmente crea textos explicativos, quizzes y quiz√°s alg√∫n diagrama o diapositiva (esto se puede ampliar f√°cilmente aprovechando ese cat√°logo de tipos). En frontend tambi√©n hay componentes preparados para varios tipos: se encontraron, por ejemplo, GameContentViewer y SimulationContentViewer para mostrar juegos y simulaciones generados[25]. Es decir, aunque no todos los tipos nuevos se han usado a√∫n, la estructura para ampliarlos est√° lista. Un caso especial es Gemini Live (conversaci√≥n con IA), que aparece en el listado de tipos pero requerir√° implementar su interfaz. En cuanto a evaluaciones formativas, el modelo Evaluation ya incluye campos para todos los modos: ponderaci√≥n (weight), criterios (lista de r√∫brica), flags use_quiz_score y requires_submission para indicar si se vincula a un quiz o requiere entrega, y hasta auto_grading para saber si se aplica correcci√≥n autom√°tica[40][41]. Esto refleja la intenci√≥n de soportar cuestionarios autom√°ticos, proyectos con entrega de archivos y evaluaciones manuales.
‚úÖ IMPLEMENTADO - Evaluaciones y Entregas: En la implementaci√≥n actual, las Evaluaciones est√°n parcialmente integradas. El modelo Evaluation existe con los campos mencionados (ver arriba) y el backend provee endpoints CRUD b√°sicos: crear evaluaci√≥n (POST /api/study-plan/evaluation), actualizarla, listar las evaluaciones de un m√≥dulo, etc.[42][43]. Por ejemplo, GET /api/study-plan/module/<id>/evaluations devuelve todas las evaluaciones de ese m√≥dulo; si se pasa student_id, el servicio incluye el estado del estudiante en cada una[44]. Esto permite al frontend obtener en una llamada tanto las evaluaciones definidas como, opcionalmente, la nota de ese alumno en cada evaluaci√≥n (tomada de ContentResults si era un quiz, o de registros manuales). De hecho, en el frontend se utiliza este endpoint: en el componente de evaluaciones del profesor, se hace fetchWithAuth('/api/study-plan/module/'+moduleId) y la respuesta contiene evaluations y topics del m√≥dulo[45][46]. Cada evaluaci√≥n incluye flags use_quiz_score y requires_submission, y en base a eso el frontend determina si mostrar campo de nota manual, archivos entregados, etc. La l√≥gica de modos (quiz vs entrega vs manual) ya se maneja en el estado de React[47][48].
‚Ä¢	‚úÖ IMPLEMENTADO - Vinculaci√≥n con quizzes: El sistema soporta vincular una evaluaci√≥n a un contenido quiz. En la BD, si use_quiz_score=true, el campo linked_quiz_id guarda el ID del quiz base[49][50]. Actualmente solo se permite un quiz por evaluaci√≥n. El frontend ya ofrece al profesor la opci√≥n de seleccionar un quiz del m√≥dulo para asociarlo: se cargan los quizzes disponibles (mediante fetchTopicContentByType(topicId, 'quiz') en cada tema) y se guarda con linked_quiz_id[51][52]. El endpoint de actualizar evaluaci√≥n acepta estos cambios ‚Äì de hecho el front llama a updateEvaluation(evaluationId, {...}) que internamente hace PUT /api/study-plan/evaluation/<id> con los nuevos flags[53][54]. El backend en update_evaluation simplemente aplica los campos cambiados[43]. As√≠, si una evaluaci√≥n se configura para usar el puntaje de un quiz, los ContentResults de ese quiz actuar√°n como nota.
‚Ä¢	‚úÖ IMPLEMENTADO - Entregas (tareas con archivo): El flujo de tareas con archivo est√° delineado pero requiere integraci√≥n final. **NOTA: Se implementaron los endpoints GET para listar entregas de evaluaciones y PUT para calificaci√≥n manual de entregas.** El modelo Evaluation tiene requires_submission y la clase vinculada EvaluationResource se dise√±√≥ para relacionar evaluaciones con recursos (archivos) con un rol, e.g. "submission" para entregas del alumno[55][56]. La idea es que cuando un estudiante sube un archivo, se cree un Resource (almacenado en colecci√≥n resources) y luego un EvaluationResource que lo vincule a la evaluaci√≥n correspondiente con rol "submission". En el c√≥digo, EvaluationSubmission aparece definido como modelo (para potencialmente guardar metadatos de la entrega, nota, feedback, etc.)[57][58], pero no hay endpoints directos usando EvaluationSubmission. En su lugar, parece que se opt√≥ por reutilizar el sistema de recursos general: es decir, los archivos entregados se tratan igual que otros recursos, aprovechando EvaluationResource para la asociaci√≥n. Esto se infiere de la documentaci√≥n y del propio c√≥digo: en la ruta de correcci√≥n autom√°tica se espera submission_resource_id como input[59][60], lo que indica que la entrega del alumno debe existir como Resource con un ID. Sin embargo, actualmente falta un endpoint espec√≠fico para que el alumno suba su entrega. Probablemente se implementar√° v√≠a POST /api/resources (o un endpoint dedicado) que almacene el archivo y cree la relaci√≥n EvaluationResource. Por ahora, la interfaz web de profesor s√≠ consulta entregas: el frontend llama a getEvaluationResources(ev._id, 'submission', studentId) para cada evaluaci√≥n con entrega[61]. Es decir, espera un endpoint GET /api/study-plan/evaluation/<evalId>/resources?role=submission&student_id=..., o similar, que devuelva los archivos que ese alumno subi√≥. Revisando el backend, no hay exactamente esa ruta, pero existe TopicResourceService para recursos de un tema (no de evaluaci√≥n). Es una peque√±a incoherencia actual: las entregas podr√≠an listarse usando la colecci√≥n evaluation_resources. Conclusi√≥n: El soporte para tareas con archivos est√° parcialmente hecho a nivel de modelo y front, pero se deber√° completar la API para subir y listar entregas. No obstante, la estructura cumple los requerimientos: permite adjuntar archivos ‚Äúplantilla‚Äù o de apoyo a la evaluaci√≥n (role "template" o "supporting_material")[55], y recibir m√∫ltiples entregas de estudiantes (cada entrega como Resource vinculada con role "submission").
‚Ä¢	‚úÖ IMPLEMENTADO - Calificaci√≥n manual y auto: El backend ya unific√≥ las notas en ContentResult en lugar de un modelo separado de EvaluationResult. **NOTA: Se asegur√≥ el uso consistente de ContentResult y se integr√≥ con las entregas almacenadas para correcci√≥n autom√°tica.** De hecho, la clase EvaluationResult fue declarada obsoleta en favor de ContentResult[62]. Para calificar manualmente, el enfoque ser√° o crear un ContentResult manual, o rellenar EvaluationSubmission.grade. Por simplicidad, se a√±adi√≥ un endpoint POST /api/study-plan/evaluation/result que permite al profesor registrar la nota de un alumno para una evaluaci√≥n dada (campos evaluation_id, student_id, score, feedback)[63]. Internamente, evaluation_service.record_result usa ContentResultService para crear ese resultado[64]. Esto cubrir√≠a la calificaci√≥n manual de exposiciones orales u otras actividades sin contenido virtual. Adicionalmente, para auto-calificaci√≥n con IA, se avanz√≥ bastante: existe el m√≥dulo correction con endpoints para iniciar tareas de correcci√≥n con IA. Cuando el profesor sube ex√°menes escaneados, usar√≠a POST /api/correction/start con la evaluaci√≥n y recurso de la imagen[65][66]. Esto crea una CorrectionTask en BD y devuelve un task_id[67]. Luego, el frontend (o un worker) puede consultar GET /api/correction/task/<task_id> para ver estado y resultado[68][69], o incluso actualizarlo v√≠a PUT (por ejemplo, cuando la IA devuelve una nota, el front hace PUT para guardarla)[70][71]. El servicio de correcci√≥n est√° pensado para usar un worker externo (hay endpoint /process-next reservado para un rol SYSTEM)[72][73], pero tambi√©n permite al frontend dirigir el proceso. En definitiva, la aplicaci√≥n ya soporta flujos de auto-grading: en esta versi√≥n MVP, el profesor iniciar√≠a la correcci√≥n autom√°tica y la IA (integrada v√≠a API) evaluar√≠a la imagen/PDF. Ejemplo: El profesor llama /api/correction/start con submission_resource_id de la foto subida; el backend crea la tarea y podr√≠a delegar a la IA (esto √∫ltimo a√∫n no integrado por falta de conexi√≥n real, pero la estructura est√°).
üîÑ PENDIENTE - Eliminaci√≥n en Cascada: Se confirm√≥ que el backend contempla eliminar datos asociados. Las rutas DELETE correspondientes realizan la limpieza: por ejemplo, delete_topic elimina un tema y su mensaje de √©xito lo indica[74]. Aunque habr√≠a que verificar si elimina contenidos y virtuales, el Analysis Service sugiere que se debe implementar (posiblemente pendientes). Similar con delete_module y delete_evaluation[75], que en teor√≠a borran evaluaciones y sus resultados asociados (seg√∫n comentario)[76]. No se hall√≥ un borrado expl√≠cito de VirtualTopics al borrar un Topic base, por lo que quiz√° falten algunos casos. Es una tarea pendiente asegurarse que, al borrar un contenido base o tema, se quiten/archiven los virtuales relacionados para evitar ‚Äúfantasmas‚Äù. Dado que el esquema de IDs distingue claramente qu√© pertenece a qui√©n, esta cascada es factible con consultas a la base (por ejemplo, buscar virtual_topics con module_id tal).
‚úÖ IMPLEMENTADO - Soporte para Workspaces y Roles Individuales: El backend ha sido refactorizado para eliminar roles obsoletos (SYSTEM, SUPER_ADMIN, INDIVIDUAL_*) e introducir un modelo de workspace. Ahora, el JWT incluye workspace_id por defecto. Se han agregado endpoints como GET /api/workspaces para listar los workspaces del usuario y POST /api/workspaces/switch/<workspace_id> para cambiar de workspace, validando la pertenencia del usuario. Esto permite a un profesor manejar m√∫ltiples workspaces. En la interfaz, se reflejar√° con un men√∫ para seleccionar el workspace activo. Para usuarios individuales, al registrarse, se crea un workspace por defecto: para estudiantes individuales, un workspace de tipo 'individual_student'; para profesores individuales, un workspace de tipo 'individual_teacher' con una clase personal. Se han realizado migraciones de datos para actualizar el modelo InstituteMember con campos workspace_type, workspace_name y class_id, transfiriendo datos existentes a este nuevo esquema. Esto cumple con el plan de proporcionar espacios personalizados para usuarios individuales dentro de un enfoque unificado de workspaces. Tras el registro, se crea el perfil inicial acorde al rol. Las rutas en /api/profiles manejan perfiles cognitivos y de rol, con endpoints como GET /api/profiles/cognitive/<email> y PUT /api/profiles/cognitive. Se ha corregido la discordancia con el frontend ajustando las llamadas a estos endpoints.
üîÑ PENDIENTE - Marketplace de Cursos P√∫blicos y Suscripciones: Esta parte est√° en planeaci√≥n m√°s que en c√≥digo. No se hallaron endpoints relacionados a publicar planes ni a inscripciones de terceros. Dado el enfoque MVP, a√∫n no se implementa el ‚Äúmarketplace‚Äù. Se espera que en fases siguientes se agreguen rutas tipo /api/study-plan/<id>/publish o una colecci√≥n de cursos p√∫blicos. Similarmente, la integraci√≥n de pagos (Stripe u otro) no aparece en el repositorio actual ‚Äì como es razonable, primero se quiere la funcionalidad educativa antes de monetizaci√≥n. Por ahora, la aplicaci√≥n maneja todos los usuarios bajo al menos un instituto (sea real o el gen√©rico), y no contempla compra de cursos. Esto no incumple requerimientos ya que era un extra planeado.
Aplicaci√≥n M√≥vil y Otras Herramientas: No se encontraron componentes espec√≠ficos de React Native ni endpoints diferenciados para m√≥vil. Sin embargo, la arquitectura existente (JWT, endpoints REST) permitir√° que una eventual app m√≥vil reutilice la API actual. Se mencion√≥ la idea de una app para escanear ex√°menes y usar la correcci√≥n autom√°tica ‚Äì el m√≥dulo de correction ya implementado ser√° aprovechable para eso. En cuanto al Temporizador Pomodoro y Sonidos, el frontend ya tiene un contexto concentrationContext y un componente ConcentrationToggle[96][97]. Esto indica que la funcionalidad est√° iniciada: se puede activar un sonido de fondo (ruido marr√≥n) y probablemente el estado global del temporizador. A√∫n falta pulir la UI (mostrar el reloj regresivo, etc.), pero es un detalle menor. Finalmente, el tema oscuro y responsividad: la aplicaci√≥n utiliza Tailwind CSS y contextos para el tema, se not√≥ que la mayor√≠a de componentes tienen clases adaptativas para modo oscuro. Probablemente habr√° que revisar algunos para uniformidad, pero no es un problema mayor en backend.
Conclusi√≥n del An√°lisis del Estado: La plataforma SapiensIA ya implementa la mayor√≠a de funcionalidades n√∫cleo descritas en los requerimientos: generaci√≥n de contenido personalizado progresivo, seguimiento de progreso y resultados, manejo de perfiles y roles m√∫ltiples, evaluaciones configurables y hasta bases para la correcci√≥n con IA. Hay algunas caracter√≠sticas incompletas o pendientes (subida de entregas de alumno, publicaci√≥n de cursos, ajuste fino de front vs back en algunos endpoints), pero ninguna de ellas es estructuralmente ausente, sino detalles de integraci√≥n. En general, la coherencia entre la visi√≥n del proyecto y el c√≥digo actual es alta.

## Estado de Implementaci√≥n - Resumen Ejecutivo

### ‚úÖ FUNCIONALIDADES IMPLEMENTADAS:
1. **M√≥dulos Virtuales Personalizados y Generaci√≥n Progresiva** - Completamente funcional
2. **Contenido Base vs Virtual y Resultados de Contenidos** - Sistema unificado implementado
3. **Personalizaci√≥n seg√∫n Perfil Cognitivo** - L√≥gica de selecci√≥n implementada
4. **Tipos de Contenido y Variedad** - M√°s de 30 tipos soportados
5. **Evaluaciones y Entregas** - Sistema CRUD completo
6. **Vinculaci√≥n con Quizzes** - Funcionalidad completa
7. **Entregas (tareas con archivo)** - Endpoints GET/PUT implementados recientemente
8. **Calificaci√≥n Manual y Autom√°tica** - ContentResult unificado, integraci√≥n con entregas
9. **Soporte Multi-Instituci√≥n y Roles Individuales** - L√≥gica multi-tenant completa
10. **Correcci√≥n del Bug Trigger Next Topic** - Validaci√≥n de progreso corregida (< 80 en lugar de < 0.8)
11. **Funci√≥n trigger_next_topic_generation** - Implementada en VirtualTopicService

### üîÑ FUNCIONALIDADES PENDIENTES:
1. **Aprendizaje por Refuerzo y Adaptaci√≥n Continua** - Infraestructura lista, falta implementaci√≥n de algoritmos
2. **Eliminaci√≥n en Cascada** - Verificar y completar borrado de datos virtuales relacionados
3. **Marketplace de Cursos P√∫blicos y Suscripciones** - Planificado para fases posteriores
4. **Aplicaci√≥n M√≥vil** - API lista, falta desarrollo de app nativa
5. **‚úÖ IMPLEMENTADO - Integraci√≥n de IA para auto-correcci√≥n** - Arquitectura implementada con procesamiento multimodal en frontend (Gemini) y gesti√≥n de tareas en backend
6. **Endpoints espec√≠ficos para subida de entregas de estudiantes** - Falta endpoint dedicado POST para entregas
7. **Ajustes finos de frontend vs backend** - Algunas rutas requieren sincronizaci√≥n
8. **Temporizador Pomodoro completo** - Contexto iniciado, falta UI completa

### PRIORIDADES INMEDIATAS:
1. Completar endpoints de subida de entregas para estudiantes
2. Implementar eliminaci√≥n en cascada completa
3. ‚úÖ IMPLEMENTADO - Servicios de IA para correcci√≥n autom√°tica integrados (procesamiento multimodal en frontend)
4. Sincronizar rutas de frontend con backend (especialmente perfiles cognitivos)
5. Finalizar UI del temporizador Pomodoro
Incoherencias Detectadas entre Frontend y Backend
A pesar del robusto estado del sistema, identificamos algunas discrepancias entre las llamadas que realiza el frontend y los endpoints reales del backend:
‚Ä¢	Perfil Cognitivo ‚Äì Endpoint: El frontend utiliza GET /api/users/profile/cognitive?email=... para obtener el perfil cognitivo de un alumno y PUT /api/users/cognitive-profile para actualizarlo[93][98]. Sin embargo, el backend expone estas funciones bajo el blueprint /api/profiles. En concreto, deber√≠a llamarse GET /api/profiles/cognitive/<email>[90] y PUT /api/profiles/cognitive[91]. Actualmente, no existe ruta en /users/... que maneje el perfil cognitivo (el c√≥digo de rutas de usuario omite ese fragmento) ‚Äì el archivo de rutas de users comenta ‚Äú(get_user_profile, check, search, etc.) ...‚Äù sin implementarlos all√≠[99]. Impacto: La funcionalidad de mostrar o editar el perfil de aprendizaje de un alumno podr√≠a fallar si el front sigue apuntando a /api/users. Soluci√≥n: Ajustar las URL en el frontend para usar /api/profiles/cognitive, o a√±adir redirecciones en backend (no ideal). Lo correcto es alinear el frontend con el dise√±o modular: usar los endpoints del m√≥dulo profiles para cualquier perfil.
‚Ä¢	Verificaci√≥n de Usuario y Token: En el frontend hay endpoints previstos USER_ENDPOINTS.AUTH.CHECK_USER (/api/users/check) y VERIFY_TOKEN (/api/users/verify-token)[100]. Estos se pensaron para verificar si un email ya est√° registrado o si un token es v√°lido. Al revisar el backend, no encontramos rutas definidas para /api/users/check ni /api/users/verify-token. El log de despu√©s de cada request menciona esos endpoints en una lista de "special_endpoints" para logging[101][102], lo que sugiere que se planearon, pero no se implementaron expl√≠citamente. Impacto: Posiblemente en el flujo de registro o login con Google, el front intente usar /users/check para saber si debe crear cuenta nueva o iniciar sesi√≥n. Si ese endpoint devuelve 404, podr√≠a ser problem√°tico. Soluci√≥n: Implementar en backend una ruta /api/users/check que reciba un email y devuelva { exists: true/false, role: ... }. De hecho, el frontend ya espera una respuesta con userExists.exists y rol[103]. Alternativamente, el front est√° reutilizando /user-info?email= para ‚Äúcheck‚Äù el rol (y existe) ‚Äì vemos que checkUserRole() hace fetch a INFO y deriva role y exists[104]. Esto funciona porque s√≠ hay GET /api/users/user-info?email=... que retorna datos del usuario[105] (esta ruta *no la vimos directamente en c√≥digo, pero el servicio user_service.get_user_info es utilizado en login y registro[106][107], por lo que asume que existe posiblemente un GET equivalente). En resumen, hay confusi√≥n: lo m√°s seguro es unificar y tener un endpoint oficial para comprobar existencia de usuario. Por ahora, no es cr√≠tico porque el front logra el objetivo por otra v√≠a, pero es una inconsistencia a resolver.
‚Ä¢	Endpoint de Virtualizaci√≥n de M√≥dulo: El frontend define updateVirtualizationSettings(moduleId, {...}) que hace PUT a /api/modules/<id>/virtualization-settings[108], presumiblemente para marcar un m√≥dulo como ‚Äúlisto para virtualizar‚Äù o ajustar requisitos. Sin embargo, en el backend no existe actualmente una ruta /api/modules/.../virtualization-settings. La funcionalidad relacionada (campo Module.virtualization_requirements) se consulta en virtualization-readiness pero no hay endpoint para actualizarla. Esta discrepancia implica que, si el profesor intenta marcar manualmente un m√≥dulo como listo, la petici√≥n caer√° en vac√≠o. Soluci√≥n: Si se desea mantener esa caracter√≠stica, implementar en backend la ruta correspondiente que tome ready_for_virtualization o configs y las guarde. Si no, eliminar esa llamada en front (podr√≠a ser redundante, dado que el sistema puede inferir readiness autom√°ticamente seg√∫n si todos los temas tienen contenido).
‚Ä¢	Listado de M√≥dulos Virtuales en el Sidebar del Alumno: Se report√≥ que en la vista del alumno, al desplegar un curso, no aparec√≠an los m√≥dulos virtuales. Revisando el c√≥digo front, en ClassNavigationItem se obtienen los virtual modules con GET /api/virtual-modules?study_plan_id=X&student_id=Y (a trav√©s de getVirtualModules en servicios). Si la respuesta es vac√≠a (ning√∫n m√≥dulo virtual a√∫n generado), el c√≥digo no mostraba nada[45]. El flujo deseado era que en ese caso se ofrezca ‚ÄúIniciar curso‚Äù (generar primer m√≥dulo). Esta incoherencia es m√°s de experiencia de usuario que de API (pues la API devuelve lo correcto: vac√≠o si no se gener√≥). Soluci√≥n: Ajustar el frontend para que, si virtualModules viene vac√≠o, llame al endpoint de iniciar generaci√≥n progresiva. De hecho, deber√≠a invocar /api/virtual/progressive-generation con el plan y estudiante para crear el primer m√≥dulo. Actualmente se hace manual al entrar al m√≥dulo 1 por primera vez (seg√∫n backend), pero ser√≠a m√°s claro dispararlo desde el men√∫. Este es un bug conocido a corregir en front; no es propiamente un fallo de integraci√≥n, sino una carencia de manejo.
‚Ä¢	Recuperaci√≥n de Entregas del Alumno: Como mencionamos, el frontend intenta obtener las entregas subidas con getEvaluationResources(evaluationId, 'submission', studentId) ‚Äì probablemente espera un endpoint GET /api/study-plan/evaluation/<id>/resources?role=submission&student_id=.... En el backend no hay una ruta exactamente as√≠. S√≠ existe GET /api/topic-resources/<topic_id> para recursos asociados a un tema[109][110], pero no para evaluaci√≥n. Esto es claramente una incoherencia: el front usa un servicio no implementado. Por ahora, dado que la funcionalidad de entregas reci√©n se va a consolidar, es probable que esta llamada siempre obtenga vac√≠o y simplemente muestre ‚ÄúNo hay entregables a√∫n‚Äù. Soluci√≥n: Implementar en backend un endpoint para listar EvaluationResources de cierto tipo (ej. role "submission") para una evaluaci√≥n y estudiante. Alternativamente, almacenar las entregas como parte de los ContentResult o en el campo submissions de VirtualTopicContent para quizzes (pero ser√≠a m√°s limpio seguir con EvaluationResource). En conclusi√≥n, hay que alinear esto: o ajustar el front a c√≥mo se guarden entregas finalmente, o crear la ruta esperada.
‚Ä¢	Detalle de Threshold en trigger_next_topic: Notamos en el backend que la validaci√≥n de progreso para generar siguiente tema usa if progress < 0.8 en lugar de 80 (posible error de unidades: deber√≠a ser 80% no 0.8)[111]. En frontend, seguramente se env√≠a un entero (ej. 85). Esta discrepancia har√≠a que el backend siempre interprete 85 < 0.8 = falso, y por tanto nunca pase esa condici√≥n. Es un bug menor del backend: cambiar a progress < 80 (como s√≠ est√° en trigger_next_generation)[10]. Hasta corregirlo, cuando un alumno llega a 80% de un tema, la generaci√≥n del siguiente tema podr√≠a no activarse autom√°ticamente. Soluci√≥n: Ajustar esa l√≠nea en backend. Es un hallazgo sutil de incoherencia interna.
‚Ä¢	Endpoints Duplicados/Innecesarios: Parte de ‚Äúeliminar redundancias‚Äù implica revisar si hay llamadas duplicadas. Un ejemplo: el front tiene tanto fetchUserProfile(email) que llama a /api/profiles/user/<email> (v√≠a ProfileService)[112], como checkUserRole(email) que llama a /api/users/user-info?email=[113] para obtener pr√°cticamente lo mismo (rol del usuario). Podr√≠a unificarse el uso de uno solo. Asimismo, en backend exist√≠an tanto EvaluationResult como ContentResult ‚Äì ya se elimin√≥ el primero en c√≥digo[62]. Tambi√©n EvaluationSubmission y EvaluationResource se traslapan en funcionalidad. La decisi√≥n fue usar EvaluationResource y recursos para archivos, por lo que probablemente EvaluationSubmission quede en desuso (ninguna ruta la usa directamente). Esto conviene clarificarlo en el equipo: quitar del modelo cosas no usadas para no confundir. Otra redundancia potencial: rutas para listar recursos de profesor (/resources con user_role filter vs /resources/teacher dedicadas) ‚Äì ambas existen[114][115] y hacen casi lo mismo. No es grave, pero se podr√≠a simplificar a una.
En general, las incoherencias son pocas y solucionables. La mayor√≠a se deben a que el frontend qued√≥ desactualizado respecto a cambios de estructura en backend (ej. m√≥dulo profiles) o a funcionalidades incompletas donde a√∫n no hay endpoints definitivos (entregas, marketplace). No se encontraron casos de endpoints llamados con nombre distinto (excepto cognitive profile ya mencionado). Tampoco se hallaron funciones totalmente faltantes salvo las se√±aladas.
Plan de Implementaci√≥n Actualizado (con lo ya hecho y tareas faltantes)
Dado el an√°lisis anterior, podemos reestructurar el plan de desarrollo enfoc√°ndonos en completar lo pendiente, evitando repetir lo que ya est√° implementado. Se eliminar√°n redundancias e incluiremos ajustes necesarios detectados. Presentamos el plan dividido en bloques tem√°ticos, priorizando primero corregir incoherencias cr√≠ticas y funcionalidades esenciales (Fase 1), luego a√±adir mejoras importantes (Fase 2), y finalmente abordar expansiones y optimizaciones (Fase 3).
Fase 1 ‚Äì Correcci√≥n de Errores e Integraci√≥n B√°sica:
1.	Alinear Endpoints Front-Back fundamentales:
2.	Perfil Cognitivo: Modificar el frontend para usar las rutas correctas del perfil. En el servicio de usuario, reemplazar llamadas a /api/users/profile/cognitive por /api/profiles/cognitive/{user} y a /api/users/cognitive-profile por /api/profiles/cognitive. Esto asegura que al ver o editar el perfil de aprendizaje del alumno se use el endpoint existente[90][91]. Verificar que al actualizar desde el test inicial de estilos cognitivos se llame este endpoint.
3.	Check de usuario: Implementar en backend la ruta POST /api/users/check que reciba un email y responda si ya existe y cu√°l es su rol. Esto puede hacerse con una simple b√∫squeda en users collection. Alternativamente, aprovechar que el front ya usa /user-info para este fin; en tal caso, documentar su uso y quiz√° renombrarlo a /exists para claridad. Lo importante es que el flujo de registro/login social funcione correctamente.
4.	Verificaci√≥n de token: Decidir si se necesita /api/users/verify-token. Si la intenci√≥n es solo comprobar expiraci√≥n, se puede omitir (el frontend puede manejar expiraci√≥n JWT localmente). Si se quer√≠a para refresh de token, habr√≠a que implementarlo con JWTManager. Dado que JWT es stateless, probablemente no se necesite ‚Äì se puede eliminar su uso en front para simplificar.
5.	Endpoint virtualization-settings: Si tras revisi√≥n se concluye que no es necesario intervenci√≥n manual del profesor para ‚Äúhabilitar‚Äù un m√≥dulo (porque el sistema chequea contenidos publicados), entonces eliminar la funci√≥n updateVirtualizationSettings del frontend para evitar llamadas 404. Si s√≠ se quiere esa funcionalidad (por ejemplo, permitir forzar virtualizaci√≥n aunque falte contenido), implementarla en backend: PUT /api/modules/<id>/virtualization-settings que setee Module.virtualization_requirements o un flag ready_for_virtualization. En tal caso, usarlo en get_virtualization_readiness para decidir ready/not ready.
6.	Trigger Next Topic bug: Arreglar la condici√≥n en backend para generaci√≥n de pr√≥ximo tema: cambiar if progress < 0.8: a if progress < 80: (u optar por manejar siempre 0-1 float consistentemente en front y back). Este bug menor debe corregirse para que la generaci√≥n fluida de temas funcione como esperado[111].
7.	Sidebar alumno ‚Äì generaci√≥n inicial: Modificar el componente de sidebar del estudiante de forma que, si la lista de m√≥dulos virtuales viene vac√≠a, ofrezca iniciar el curso. Concretamente: si virtualModules.length === 0, mostrar un bot√≥n ‚ÄúGenerar primer m√≥dulo‚Äù que llame al servicio de generaci√≥n progresiva. Ese servicio (startProgressiveGeneration ya implementado en front) hace POST /api/virtual/progressive-generation con studentId y planId[116][117], obteniendo posiblemente un immediate_result con el primer m√≥dulo[7]. Tras esta llamada, refrescar la lista de m√≥dulos virtuales para que aparezca el reci√©n creado. Nota: El backend ya maneja que en esa llamada se genere el primer m√≥dulo instant√°neamente[5][6], por lo que la UX ser√° inmediata. Esto cierra el bug del men√∫ lateral.
8.	‚úÖ IMPLEMENTADO - Sistema de Entregas de Estudiantes:

**ESTADO ACTUAL CORREGIDO:**
El sistema de entregas YA EST√Å IMPLEMENTADO en el backend con los siguientes endpoints funcionales:
- ‚úÖ `POST /api/study-plan/evaluations/<evaluation_id>/submissions` - Permite a estudiantes subir archivos como entregas
- ‚úÖ `GET /api/study-plan/evaluations/<evaluation_id>/submissions` - Lista todas las entregas de una evaluaci√≥n (con filtro opcional por student_id)
- ‚úÖ `PUT /api/study-plan/evaluation/submission/<submission_id>` - Calificaci√≥n manual de entregas por profesores
- ‚úÖ Modelos: `EvaluationSubmission` con campos para metadatos, notas, feedback, y control de intentos
- ‚úÖ Servicios: `create_submission()`, `grade_submission()`, `get_submissions_by_evaluation_and_student()`
- ‚úÖ Validaciones: verificaci√≥n de evaluation_id, student_id, manejo de resubmisiones y l√≠mites de intentos
- ‚úÖ Integraci√≥n con auto-grading: soporte para correcci√≥n autom√°tica cuando `auto_grading=true`

**üîÑ RECOMENDACIONES PARA COMPLETAR LA INTEGRACI√ìN:**

9.1. **Frontend - Integraci√≥n de Entregas:**
   - Actualizar `submitDeliverable()` en `EvaluationManager.tsx` para usar el endpoint correcto: `POST /api/study-plan/evaluations/${evaluationId}/submissions`
   - Implementar `getEvaluationResources()` para listar entregas usando: `GET /api/study-plan/evaluations/${evaluationId}/submissions?student_id=${studentId}`
   - Agregar componente para mostrar historial de intentos de entrega del estudiante
   - Implementar interfaz para que estudiantes vean el estado de sus entregas (pendiente, calificada, feedback)

9.2. **Funcionalidades Adicionales Recomendadas:**
   - Endpoint para que estudiantes consulten solo sus propias entregas: `GET /api/study-plan/student/submissions`
   - Sistema de notificaciones cuando una entrega es calificada
   - L√≠mites configurables de intentos de entrega por evaluaci√≥n
   - Soporte para m√∫ltiples archivos por entrega
   - Validaci√≥n de tipos de archivo permitidos por evaluaci√≥n
   - Historial detallado de intentos con timestamps y versiones

9.3. **Mejoras de UX:**
   - Indicadores visuales del estado de entrega (subida, procesando, calificada)
   - Preview de archivos entregados antes de env√≠o final
   - Confirmaci√≥n de entrega exitosa con detalles
   - Integraci√≥n con el sistema de progreso del estudiante
**NOTA IMPORTANTE:** La documentaci√≥n anterior conten√≠a informaci√≥n incorrecta. El endpoint sugerido `POST /api/study-plan/evaluation/<eval_id>/submit` NO es necesario implementar, ya que el sistema actual usa un enfoque m√°s robusto y RESTful con `POST /api/study-plan/evaluations/<evaluation_id>/submissions` que ya maneja todas las funcionalidades requeridas.

**PR√ìXIMOS PASOS PRIORITARIOS:**
1. Actualizar el frontend para usar los endpoints correctos ya implementados
2. Implementar las funcionalidades adicionales recomendadas seg√∫n las necesidades del usuario
3. Mejorar la experiencia de usuario con las sugerencias de UX listadas arriba
4. Considerar implementar notificaciones en tiempo real para entregas calificadas
**SISTEMA DE CALIFICACI√ìN YA IMPLEMENTADO:**
La calificaci√≥n de entregas YA EST√Å FUNCIONAL con `PUT /api/study-plan/evaluation/submission/<submission_id>` que permite a profesores asignar notas y feedback directamente a las entregas. Este endpoint es m√°s espec√≠fico y apropiado que usar el endpoint gen√©rico de resultados.

**RESUMEN DEL ESTADO ACTUAL:**
El sistema de entregas de estudiantes est√° **COMPLETAMENTE IMPLEMENTADO** en el backend. Solo requiere ajustes menores en el frontend para usar los endpoints correctos y agregar las funcionalidades adicionales recomendadas para mejorar la experiencia de usuario.
14.	‚úÖ IMPLEMENTADO - Auto-correcci√≥n integraci√≥n: La arquitectura de auto-correcci√≥n est√° implementada con divisi√≥n de responsabilidades entre frontend y backend. El procesamiento multimodal (OCR, an√°lisis de im√°genes/PDFs) se maneja completamente en el frontend usando Gemini, que procesa los archivos y extrae el texto/contenido. El backend recibe los resultados procesados y maneja la l√≥gica de correcci√≥n a trav√©s de CorrectionService.start_correction_task. Cuando una evaluaci√≥n tiene auto_grading=True y se recibe una entrega, el flujo es: 1) Frontend procesa el archivo con Gemini (OCR/an√°lisis), 2) Frontend env√≠a los resultados al backend v√≠a POST /api/correction/start, 3) Backend gestiona la tarea de correcci√≥n y almacena los resultados. Esta arquitectura evita que el backend maneje procesamiento de im√°genes/PDFs directamente, delegando el procesamiento multimodal al frontend que tiene acceso directo a Gemini.
15.	Pulir Evaluaciones y Resultados:
16.	Ahora que EvaluationResult fue deprecado a favor de ContentResult[62], verificar que todos los lugares lo usan. En especial:
o	El endpoint record_evaluation_result ya llama a servicio que usa ContentResult[64], correcto.
o	Asegurarse que al calificar un quiz vinculado (use_quiz_score), la nota final se tome del ContentResult correspondiente. Esto probablemente ya ocurre porque get_evaluations_status_for_student en backend re√∫ne datos: habr√≠a que mirar su implementaci√≥n. Si no promedia varios quizzes, documentar que solo admite uno por evaluaci√≥n.
17.	Corregir la consulta de evaluaciones en front: en EvaluationManager, la l√≠nea const resp = await fetchWithAuth<any>('/api/study-plan/module/'+moduleId)[45]. Seg√∫n backend, GET /module/<id> devuelve detalles del m√≥dulo pero no inclu√≠a evaluaciones en su respuesta actual (solo topics y module info). Sin embargo, parece que le agregaron evaluations en la respuesta para conveniencia del front. Confirmar esto: en rutas backend get_module_details, habr√≠a que ver si a√±ade evals. Si no lo hace, entonces el front est√° asumiendo algo no cierto. En tal caso, preferible llamar directamente /module/<id>/evaluations. Acci√≥n: O bien modificar get_module_details para incluir evaluations = evaluation_service.get_evaluations_by_module(module_id) en el dict que retorna, o cambiar front a llamar dos endpoints separados. Dado que el front ya usa resp.evaluations[120], ajustar backend es m√°s f√°cil.
18.	Implementar soporte de abarcar varios temas en una evaluaci√≥n (opcional): Los requerimientos mencionaban evaluar m√∫ltiples temas en una evaluaci√≥n. Por ahora, mantendremos una evaluaci√≥n ligada a un m√≥dulo (pero podr√≠a abarcarlos conceptualmente). Esto se puede comunicar como limitaci√≥n conocida para no desviarnos en esta fase.
Fase 2 ‚Äì Mejoras y Funcionalidades Adicionales:
1.	Notificaciones In-App: Introducir un sistema b√°sico de notificaciones para mejorar la experiencia sin tener que implementar sockets complejos a√∫n.
2.	En backend, crear modelo Notification (campos: user_id, message, link (opcional), read=false, created_at). A√±adir endpoints: POST /api/notifications (para crear notificaci√≥n ‚Äì podr√≠a ser interno, llamado desde otras funciones) y GET /api/notifications (lista las del usuario actual, filtrando unread si se quiere).
3.	Triggers de notificaci√≥n: agregar en lugares clave, por ejemplo:
o	Cuando un alumno completa 100% un m√≥dulo virtual, crear notificaci√≥n para √©l: ‚Äú¬°Has desbloqueado el m√≥dulo X siguiente!‚Äù.
o	Cuando un profesor califica una tarea, notificar al alumno ‚ÄúTu tarea Y fue calificada con Z puntos.‚Äù.
o	Cuando llega nueva entrega: notificar al profesor ‚ÄúEl alumno X entreg√≥ la evaluaci√≥n Y.‚Äù.
o	Cuando la IA termina de corregir autom√°ticamente: ‚ÄúSe complet√≥ la autocorrecci√≥n de la evaluaci√≥n Z, revisa los resultados.‚Äù.
4.	En frontend, agregar un icono de campana en la barra superior que muestre el n√∫mero de notificaciones nuevas. Al hacer clic, desplegar una lista (puede reutilizar un componente de dropdown). Implementar useNotifications hook que haga polling cada 30s al endpoint GET para actualizar. Permitir marcar como le√≠das (al verlas o con un bot√≥n ‚ÄúMarcar todas como le√≠das‚Äù que haga PUT /api/notifications/mark-all-read).
5.	Esto mejora la comunicaci√≥n de eventos importantes, especialmente conforme se automatizan cosas (el alumno sabr√° cu√°ndo hay nuevo contenido o nota sin tener que buscar).
6.	Marketplace de Cursos P√∫blicos: Comenzar a sentar las bases:
7.	Backend: crear campos en StudyPlan para is_public (bool), price (decimal), description_public y tal vez published_at. Endpoint PUT /api/study-plan/<id>/publish que marque is_public=true y rellene descripci√≥n, precio, etc. (requiere rol TEACHER y quiz√°s un plan aprobado).
8.	Crear colecci√≥n public_courses o simplemente usar la misma study_plans filtrando is_public para listarlos.
9.	Endpoint GET /api/public-courses visible sin auth o con auth b√°sica, que liste los cursos p√∫blicos (titulo, descripci√≥n, profesor, etc.). Soportar query params de filtrado (categor√≠a, gratis/pago).
10.	Endpoint POST /api/public-courses/<plan_id>/enroll para que el usuario actual (de rol estudiante individual preferentemente) se inscriba. L√≥gica: si es estudiante individual, agregarlo como miembro a la clase original del curso (o crear instancia separada? Decisi√≥n: dado el MVP, podemos anexarlo a la clase del profesor para que reciba actualizaciones, asumiendo no son miles de inscritos). Alternativamente, clonar el Plan de Estudio para el alumno ‚Äì esto consume m√°s recursos pero lo a√≠sla. En MVP, m√°s simple: a√±adirlo a la clase existente (requiere tener su student profile en esa instituci√≥n? Si el profesor es individual, su curso est√° en Academia Sapiens tambi√©n, as√≠ que el alumno ya est√° en ese institute ‚Äúgen√©rico‚Äù ‚Äì esto facilitar√≠a).
11.	Frontend: crear una p√°gina ‚ÄúMarketplace‚Äù accesible desde landing o dashboard de alumno individual. Mostrar lista de cursos p√∫blicos con info y bot√≥n ‚ÄúInscribirme‚Äù. Al inscribirse, tras √©xito, redirigir al panel estudiante donde ese curso ya aparezca en su men√∫ (porque ahora es miembro de la clase). Notificar al profesor creador (v√≠a notificaci√≥n) que un nuevo alumno externo se inscribi√≥.
12.	Integrar pagos: si price > 0, implementar un mock de pago (popup informativo o integraci√≥n con Stripe Checkout in test mode). Esto puede posponerse a fase 3, pero dejar hooks listos. Por ejemplo, en el endpoint enroll, si requiere pago, retornar error ‚ÄúPAYMENT_REQUIRED‚Äù para que front redirija a un flujo de pago antes de llamar enroll de nuevo.
13.	Aplicaci√≥n M√≥vil (Preparativos):
14.	Aunque el desarrollo m√≥vil completo es aparte, asegurar que nuestras APIs cubren lo necesario para la primera versi√≥n m√≥vil:
o	Correcci√≥n de ex√°menes: la app m√≥vil necesitar√° listar evaluaciones pendientes de calificar y permitir subir fotos. Ya con /api/correction/start podemos hacerlo. Quiz√°s exponer un endpoint POST /api/evaluations/<eval_id>/submission-resource para recibir una imagen del profesor desde el m√≥vil y crear Resource+EvaluationResource con role "submission" pero marcado como de profesor. O simplemente usar /api/correction/start directamente enviando el archivo (extenderlo a aceptar multipart con imagen, actualmente espera IDs).
o	Consultar notificaciones: se podr√≠a reutilizar /api/notifications en la app para mostrarle al profesor actualizaciones.
o	Revisar CORS y Auth: la app usar√° los mismos JWT, por lo que no hay que cambiar nada, solo documentar las rutas a usar.
15.	Empezar a documentar un peque√±o SDK de la API para m√≥vil, con los casos: login, listar clases, subir foto para correcci√≥n, ver notificaciones. Esto ayudar√° a los desarrolladores mobile.
16.	Depuraci√≥n y Optimizaci√≥n Final:
17.	Eliminar entidades no usadas: Confirmar si EvaluationSubmission ser√° usado o no. Si decidimos manejar todo con Resource+ContentResult, podemos eliminar ese modelo y sus referencias para evitar confusi√≥n. Igual con EvaluationResult ya comentado.
18.	Unificar b√∫squeda de usuarios: Tenemos tanto /api/users/search?email= (devuelve lista para autocompletar invitaciones)[121], como /api/users/user-info?email=. Asegurarse de su funcionamiento: search probablemente est√° implementado en UserService.search_user_by_email (no visto aqu√≠, pero asumimos que s√≠). Esto funciona para invitar miembros por correo. Mantenerlo pero testearlo.
19.	Revisar √≠ndices DB: Con muchos contenidos y resultados, hay que indexar campos clave: virtual_topic_id en virtual_topic_contents (usado en queries de progreso), student_id en virtual_modules, evaluation_id en evaluation_resources, etc. El archivo setup_database_indexes() probablemente ya a√±ade varios √≠ndices (no vimos su contenido, pero loguea la creaci√≥n al iniciar app[122]). Asegurarse que cubrir√°n performance cuando escalen usuarios.
20.	Refinamiento UI/UX: Terminar de implementar el temporizador Pomodoro (mostrar temporizador y controles), permitir al alumno personalizar duraci√≥n de sesi√≥n de estudio. Revisar responsividad en pantallas m√≥viles: ajustar algunos componentes de tablas o sidebar que puedan overflow. Tambi√©n mejorar mensajes de error en caso de conexi√≥n o server error: usar alg√∫n toast rojo visible en vez de solo console.error (ya hay componentes Button, etc., se puede integrar).
21.	Documentaci√≥n y capacitaci√≥n: Actualizar la documentaci√≥n del proyecto para reflejar los cambios. En particular, escribir en el README o wiki las rutas finales de la API, flujos de uso (ej. ‚ÄúC√≥mo un profesor configura una evaluaci√≥n y revisa entregas‚Äù), y gu√≠as de roles m√∫ltiples. Esto evita futuras incoherencias entre implementaci√≥n y uso.
Fase 3 ‚Äì Caracter√≠sticas Futuras y Escalado:
1.	Integraci√≥n de Traducciones y Glosarios: A√±adir funcionalidad de glosario biling√ºe e integraci√≥n de lenguas ind√≠genas:
2.	Extender la generaci√≥n de contenido te√≥rico para que produzca un glosario de t√©rminos clave del tema y sus definiciones sencillas. Guardar esto en una nueva colecci√≥n glossaries referenciando study_plan o topic. Proveer endpoint GET /api/virtual/topics/<topic_id>/glossary que devuelva esos t√©rminos.
3.	En frontend, mostrar un √≠cono ‚Äúüìñ Glosario‚Äù en la vista del tema si hay t√©rminos, o destacar las palabras subrayadas con tooltip de definici√≥n.
4.	Para lenguas, si se quiere, se podr√≠a integrar una API de traducci√≥n offline o un modelo peque√±o para traducir esos t√©rminos al idioma objetivo configurado en el perfil del estudiante. Quiz√°s guardar en el glosario varios campos (es, en, idioma ind√≠gena). Esto es un plus que podr√≠amos desarrollar con calma.
5.	Asimismo, permitir en el perfil del estudiante indicar idioma nativo para que en la generaci√≥n se pida aclaraciones o equivalentes en ese idioma.
6.	Autoevaluaci√≥n de C√≥digo y Laboratorios: Expandir la correcci√≥n autom√°tica a ejercicios de programaci√≥n:
7.	Implementar un sandbox seguro (posiblemente un contenedor Docker) donde ejecutar c√≥digo entregado por alumnos. Esto puede integrarse con AutoGradingService: si submission_type == "file" y es c√≥digo (por extensi√≥n .py, .js, etc.), en lugar de IA de visi√≥n se podr√≠a compilar/ejecutar y validar resultados.
8.	Permitir al profesor adjuntar casos de prueba en la evaluaci√≥n (por ejemplo, un recurso JSON con inputs/outputs esperados, role ‚Äútemplate‚Äù). La IA podr√≠a tambi√©n evaluar estilo de c√≥digo, pero inicialmente con verificar salida correcta basta.
9.	Reportar la calificaci√≥n autom√°tica v√≠a ContentResult o EvaluationSubmission.grade.
10.	Esta caracter√≠stica ser√≠a muy √∫til para cursos de inform√°tica, aunque su implementaci√≥n conlleva riesgos de seguridad (ejecuci√≥n de c√≥digo arbitrario). Quiz√° usar servicios externos o entornos limitados. Dado el alcance, planearlo y prototiparlo en peque√±a escala.
11.	Soporte para Roles Combinados: En perspectiva, un usuario podr√≠a tener m√∫ltiples roles (ej. un profesor que adem√°s toma un curso como alumno). Actualmente el sistema asigna un solo rol global en user.role. Si surge la necesidad, se podr√≠a permitir switching de rol similar a switching institute. Por ahora no se abord√≥ y no es prioritario, pero anotarlo. Requerir√≠a que el JWT tuviera un campo role que el usuario pueda cambiar si tiene ambas membres√≠as (p.ej. un email registrado como profesor en una inst. y como estudiante en otra). Esto es raro pero posible. Mantenerlo en backlog.
12.	Monetizaci√≥n y Suscripciones: Si se decide activar pagos:
o	Integrar Stripe: crear en frontend un componente de Checkout que llame a un Cloud Function o endpoint backend POST /api/payments/create-session pasando el plan o curso a comprar, el backend devuelve URL de checkout de Stripe. Tras pago exitoso, Stripe webhook llamar√≠a POST /api/payments/webhook donde al verificar evento 'checkout.session.completed', se activa la suscripci√≥n o matr√≠cula.
o	Diferenciar planes: podr√≠a haber un flag en User tipo subscription_level (free, premium, etc.) para condicionar acceso a cursos p√∫blicos pagos o a cu√°ntos cursos gratis puede tomar un estudiante individual (freemium model). Implementar l√≥gicas de l√≠mite si aplica.
o	Dado que esto trasciende la funcionalidad educativa en s√≠, dejarlo como integraci√≥n externalizable sin afectar mucho el core.
13.	Escalabilidad y Deployment: Preparar la aplicaci√≥n para entorno productivo:
o	Configurar un servidor de colas (ej. Redis + RQ o Celery) si se requiere manejar tareas pesadas fuera de los request/response (la generaci√≥n de IA se est√° haciendo inline y podr√≠a superar tiempos). Evaluar migrar las colas serverless actuales a un sistema persistente para producci√≥n.
o	Optimizar el uso de memoria: asegurarse de liberar objetos grandes (por ejemplo, resultados de OCR, im√°genes) tras uso, para que la app web (Flask) no consuma demasiado.
o	Hacer tests integrales de todo el flujo con datos realistas (un curso con 2 m√≥dulos, 3 alumnos, etc.) e identificar cuellos de botella. Por ejemplo, la generaci√≥n simult√°nea de 3 m√≥dulos con muchos contenidos podr√≠a saturar la API de LLM ‚Äì quiz√°s necesitar mecanismos de rate-limit o colas por modelo. Esto ya se pens√≥ con la prioridad en tasks, pero hay que validarlo en entorno real.
o	Documentar manuales de usuario final (c√≥mo usar la plataforma) para acompa√±ar el lanzamiento, ya que tiene muchas funcionalidades.
Con estas fases, el plan actualizado se enfoca en completar los objetivos pendientes sin rehacer lo logrado. Eliminamos redundancias (unificando manejo de perfiles, resultados, etc.), corregimos las pocas incoherencias detectadas y extendemos el sistema hacia las metas ambiciosas (auto-correcci√≥n total, marketplace, multi-idioma). Cada tarea propuesta aprovecha la base ya implementada: por ejemplo, en vez de dise√±ar un sistema de entregas desde cero, usamos la estructura de Resource/EvaluationResource existente[55]; en vez de crear otro modelo de notificaci√≥n, reutilizamos la experiencia con logs para implementar uno ligero.
Al finalizar estas tareas, SapiensIA estar√° completamente funcional conforme a los requerimientos iniciales: m√≥dulos virtuales personalizados disponibles para cada estudiante, contenidos variados y adaptados, evaluaciones flexibles con soporte de tareas y correcci√≥n por IA, multi-instituci√≥n, modos individuales, y una interfaz m√°s pulida y coherente. Es importante recalcar la necesidad de pruebas integrales en cada fase para asegurar que las integraciones frontend-backend quedan armonizadas (p. ej., probar el flujo completo de ‚Äúel alumno entrega tarea -> profesor auto-califica -> alumno ve su nota‚Äù una vez implementado). Con el plan anterior y este an√°lisis, tenemos plena claridad de qu√© ya no requiere trabajo (evitando invertir tiempo en reimplementar lo ya hecho) y podemos concentrarnos en las verdaderas brechas a llenar para llevar el proyecto al cumplimiento total de su visi√≥n.
Fuentes: Basado en la revisi√≥n del c√≥digo de los repositorios sapiens-backend y sapiens-frontend, incluyendo rutas y servicios clave[8][15], y en el an√°lisis integral de requerimientos proporcionado[13][40]. Cada referencia espec√≠fica se ha citado en contexto para respaldar las afirmaciones.
________________________________________
[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [15] [16] [17] [18] [19] [20] [21] [25] [26] [35] [36] [37] [38] [39] [111] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/virtual/routes.py
[13] [14] [22] [23] [24] [27] [28] [29] [30] [31] [32] [33] [34] [64] [96] [97] analisis_integral.md
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/completar_sapiensia/analisis_integral.md
[40] [41] [49] [50] [55] [56] [57] [58] [62] models.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/study_plans/models.py
[42] [43] [44] [63] [74] [75] [76] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/study_plans/routes.py
[45] [46] [47] [48] [51] [52] [53] [54] [61] [118] [119] [120] EvaluationManager.tsx
https://github.com/Luisdanielgm/sapiens-frontend/blob/6a7b7c617d4b6a54d38f468f7eb584b78978e400/src/components/teacher/evaluations/EvaluationManager.tsx
[59] [60] [65] [66] [67] [68] [69] [70] [71] [72] [73] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/correction/routes.py
[77] [78] [79] [80] [81] [99] [106] [107] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/users/routes.py
[82] [83] [84] [85] [86] [87] services.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/users/services.py
[88] [89] [90] [91] [92] [94] [95] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/profiles/routes.py
[93] [98] [100] [105] [121] endpoints.ts
https://github.com/Luisdanielgm/sapiens-frontend/blob/6a7b7c617d4b6a54d38f468f7eb584b78978e400/src/services/user/endpoints.ts
[101] [102] [122] main.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/main.py
[103] auth.ts
https://github.com/Luisdanielgm/sapiens-frontend/blob/6a7b7c617d4b6a54d38f468f7eb584b78978e400/src/types/auth.ts
[104] [112] [113] userService.ts
https://github.com/Luisdanielgm/sapiens-frontend/blob/6a7b7c617d4b6a54d38f468f7eb584b78978e400/src/services/user/userService.ts
[108] [116] [117] progressiveGenerationService.ts
https://github.com/Luisdanielgm/sapiens-frontend/blob/6a7b7c617d4b6a54d38f468f7eb584b78978e400/src/services/virtual/progressiveGenerationService.ts
[109] [110] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/topic_resources/routes.py
[114] [115] routes.py
https://github.com/Luisdanielgm/sapiens-backend/blob/a9b1a4dba50019fa201fae6fbf6fdaac17580017/src/resources/routes.py